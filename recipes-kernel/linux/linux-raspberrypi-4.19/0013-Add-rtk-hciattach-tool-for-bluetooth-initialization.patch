From 6e8947035431da3878369e10dd04fcaea4d4daae Mon Sep 17 00:00:00 2001
From: Sophie Stupalo <sophie@stupalo.com>
Date: Thu, 28 May 2020 14:38:59 -0400
Subject: [PATCH] Add rtk-hciattach tool for bluetooth initialization

---
 .../linux/linux-raspberrypi-4.19/fragment.cfg |    1 +
 .../linux/linux-raspberrypi_4.19.bbappend     |    3 -
 .../rtk-hciattach/files/8822CS/Makefile       |    8 +
 .../files/8822CS/rtl8822cs_config             |  Bin 0 -> 33 bytes
 .../rtk-hciattach/files/8822CS/rtl8822cs_fw   |  Bin 0 -> 48920 bytes
 .../rtk-hciattach/files/LICENSE               |  340 +++
 .../files/rtk_hciattach/Makefile              |   19 +
 .../files/rtk_hciattach/hciattach.c           |  631 +++++
 .../files/rtk_hciattach/hciattach.h           |  188 ++
 .../files/rtk_hciattach/hciattach_h4.c        |  295 +++
 .../files/rtk_hciattach/hciattach_h4.h        |    7 +
 .../files/rtk_hciattach/hciattach_rtk.c       | 2024 +++++++++++++++++
 .../files/rtk_hciattach/rtb_fwc.c             | 1244 ++++++++++
 .../files/rtk_hciattach/rtb_fwc.h             |   75 +
 .../rtk-hciattach/rtk-hciattach_1.0.0.bb      |   31 +
 15 files changed, 4863 insertions(+), 3 deletions(-)
 create mode 100644 recipes-multimedia/rtk-hciattach/files/8822CS/Makefile
 create mode 100644 recipes-multimedia/rtk-hciattach/files/8822CS/rtl8822cs_config
 create mode 100644 recipes-multimedia/rtk-hciattach/files/8822CS/rtl8822cs_fw
 create mode 100644 recipes-multimedia/rtk-hciattach/files/LICENSE
 create mode 100644 recipes-multimedia/rtk-hciattach/files/rtk_hciattach/Makefile
 create mode 100644 recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach.c
 create mode 100644 recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach.h
 create mode 100644 recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach_h4.c
 create mode 100644 recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach_h4.h
 create mode 100644 recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach_rtk.c
 create mode 100644 recipes-multimedia/rtk-hciattach/files/rtk_hciattach/rtb_fwc.c
 create mode 100644 recipes-multimedia/rtk-hciattach/files/rtk_hciattach/rtb_fwc.h
 create mode 100644 recipes-multimedia/rtk-hciattach/rtk-hciattach_1.0.0.bb

diff --git a/recipes-kernel/linux/linux-raspberrypi-4.19/fragment.cfg b/recipes-kernel/linux/linux-raspberrypi-4.19/fragment.cfg
index 6bf11f8..afd3ec7 100644
--- a/recipes-kernel/linux/linux-raspberrypi-4.19/fragment.cfg
+++ b/recipes-kernel/linux/linux-raspberrypi-4.19/fragment.cfg
@@ -56,3 +56,4 @@ CONFIG_CAN=m
 CONFIG_CAN_DEV=m
 CONFIG_SPI=y
 CONFIG_HAS_DMA=y
+CONFIG_CMA_SIZE_MBYTES=128
diff --git a/recipes-kernel/linux/linux-raspberrypi_4.19.bbappend b/recipes-kernel/linux/linux-raspberrypi_4.19.bbappend
index 780c9d7..1490eea 100644
--- a/recipes-kernel/linux/linux-raspberrypi_4.19.bbappend
+++ b/recipes-kernel/linux/linux-raspberrypi_4.19.bbappend
@@ -19,6 +19,3 @@ do_configure_append() {
     ${S}/scripts/kconfig/merge_config.sh -m -O ${B} ${B}/.config ${WORKDIR}/fragment.cfg
     ${S}/scripts/kconfig/merge_config.sh -m -O ${B} ${B}/.config ${WORKDIR}/fragments/*.cfg
 }
-
-# Set contiguous memory allocation size for video streaming
-PITFT_PARAMS_append = "\n# Uncomment and add inline to optimize memory for streaming video\n# cma=64M"
diff --git a/recipes-multimedia/rtk-hciattach/files/8822CS/Makefile b/recipes-multimedia/rtk-hciattach/files/8822CS/Makefile
new file mode 100644
index 0000000..63bab6d
--- /dev/null
+++ b/recipes-multimedia/rtk-hciattach/files/8822CS/Makefile
@@ -0,0 +1,8 @@
+FW_DIR	:= /lib/firmware/rtlbt
+FW_NAME := rtl8822cs_fw
+CF_NAME := rtl8822cs_config
+all:
+	@echo "Copy RTL8822CS fw/config to $(FW_DIR)"
+	cp -f $(FW_NAME) $(FW_DIR)/$(FW_NAME)
+	cp -f $(CF_NAME) $(FW_DIR)/$(CF_NAME)
+clean:
diff --git a/recipes-multimedia/rtk-hciattach/files/8822CS/rtl8822cs_config b/recipes-multimedia/rtk-hciattach/files/8822CS/rtl8822cs_config
new file mode 100644
index 0000000000000000000000000000000000000000..2c32e0e03c087778529838295c75e91974a47da6
GIT binary patch
literal 33
pcmWGtt=ulnz{4QG)G&!9;OHyKhthx7$1^VBu3}&`zsbPJ4*;|J3S<BP

literal 0
HcmV?d00001

diff --git a/recipes-multimedia/rtk-hciattach/files/8822CS/rtl8822cs_fw b/recipes-multimedia/rtk-hciattach/files/8822CS/rtl8822cs_fw
new file mode 100644
index 0000000000000000000000000000000000000000..6d71506c7e9c9774ed53f7b8e699a524f985091a
GIT binary patch
literal 48920
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

literal 0
HcmV?d00001

diff --git a/recipes-multimedia/rtk-hciattach/files/LICENSE b/recipes-multimedia/rtk-hciattach/files/LICENSE
new file mode 100644
index 0000000..6d45519
--- /dev/null
+++ b/recipes-multimedia/rtk-hciattach/files/LICENSE
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/Makefile b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/Makefile
new file mode 100644
index 0000000..cb18b65
--- /dev/null
+++ b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/Makefile
@@ -0,0 +1,19 @@
+CFLAGS := -Wall -g
+all: rtk_hciattach
+OBJS := hciattach.o hciattach_rtk.o hciattach_h4.o rtb_fwc.o
+
+rtk_hciattach: $(OBJS)
+	 $(CC) -o rtk_hciattach $(OBJS)
+
+%.o: %.c
+	$(CC) -c $< -o $@ $(CFLAGS)
+
+clean:
+	rm -f $(OBJS)  rtk_hciattach
+
+#tags: FORCE
+#	ctags -R
+#	find ./ -name "*.h" -o -name "*.c" -o -name "*.cc" -o -name "*.cpp" > cscope.files
+#	cscope -bkq -i cscope.files
+#PHONY += FORCE
+#FORCE:
diff --git a/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach.c b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach.c
new file mode 100644
index 0000000..0a4ca71
--- /dev/null
+++ b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach.c
@@ -0,0 +1,631 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include <syslog.h>
+#include <termios.h>
+#include <time.h>
+#include <sys/time.h>
+#include <sys/poll.h>
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <sys/timerfd.h>
+
+#include "hciattach.h"
+
+#define RFKILL_NODE	"/sys/class/rfkill/rfkill0/state"
+
+#ifdef NEED_PPOLL
+#include "ppoll.h"
+#endif
+
+/* #define SCHED_ENABLE */
+
+#ifdef SCHED_ENABLE
+#include <sched.h>
+#endif
+
+struct uart_t {
+	char *type;
+	int  m_id;
+	int  p_id;
+	int  proto;
+	int  init_speed;
+	int  speed;
+	int  flags;
+	int  pm;
+	char *bdaddr;
+	int  (*init) (int fd, struct uart_t *u, struct termios *ti);
+	int  (*post) (int fd, struct uart_t *u, struct termios *ti);
+};
+
+#define FLOW_CTL	0x0001
+#define ENABLE_PM	1
+#define DISABLE_PM	0
+
+static volatile sig_atomic_t __io_canceled = 0;
+
+static void sig_hup(int sig)
+{
+	RS_INFO("signal hup.");
+}
+
+static void sig_term(int sig)
+{
+	switch (sig) {
+	case SIGINT:
+		RS_INFO("signal int.");
+		break;
+	case SIGTERM:
+		RS_INFO("signal term.");
+		break;
+	}
+	__io_canceled = 1;
+}
+
+static void sig_alarm(int sig)
+{
+	RS_ERR("Initialization timed out.");
+	exit(1);
+}
+
+static int uart_speed(int s)
+{
+	switch (s) {
+	case 9600:
+		return B9600;
+	case 19200:
+		return B19200;
+	case 38400:
+		return B38400;
+	case 57600:
+		return B57600;
+	case 115200:
+		return B115200;
+	case 230400:
+		return B230400;
+	case 460800:
+		return B460800;
+	case 500000:
+		return B500000;
+	case 576000:
+		return B576000;
+	case 921600:
+		return B921600;
+	case 1000000:
+		return B1000000;
+	case 1152000:
+		return B1152000;
+	case 1500000:
+		return B1500000;
+	case 2000000:
+		return B2000000;
+#ifdef B2500000
+	case 2500000:
+		return B2500000;
+#endif
+#ifdef B3000000
+	case 3000000:
+		return B3000000;
+#endif
+#ifdef B3500000
+	case 3500000:
+		return B3500000;
+#endif
+#ifdef B4000000
+	case 4000000:
+		return B4000000;
+#endif
+	default:
+		return B57600;
+	}
+}
+
+int set_speed(int fd, struct termios *ti, int speed)
+{
+	if (cfsetospeed(ti, uart_speed(speed)) < 0)
+		return -errno;
+
+	if (cfsetispeed(ti, uart_speed(speed)) < 0)
+		return -errno;
+
+	if (tcsetattr(fd, TCSANOW, ti) < 0)
+		return -errno;
+
+	return 0;
+}
+
+static int realtek_init(int fd, struct uart_t *u, struct termios *ti)
+{
+
+	RS_INFO("Realtek Bluetooth init uart with init speed:%d, type:HCI UART %s",
+		u->init_speed,
+		(u->proto == HCI_UART_H4) ? "H4" : "H5");
+	return rtb_init(fd, u->proto, u->speed, ti);
+}
+
+static int realtek_post(int fd, struct uart_t *u, struct termios *ti)
+{
+	RS_INFO("Realtek Bluetooth post process");
+	return rtb_post(fd, u->proto, ti);
+}
+
+struct uart_t uart[] = {
+	{ "any",     0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, DISABLE_PM, NULL, NULL},
+
+	/* Realtek Bluetooth H4 */
+	{ "rtk_h4",  0x0000, 0x0000, HCI_UART_H4,  115200,  115200, 0, DISABLE_PM, NULL, realtek_init, realtek_post },
+
+	/* Realtek Bluetooth H5 */
+	{ "rtk_h5",  0x0000, 0x0000, HCI_UART_3WIRE, 115200,115200, 0, DISABLE_PM, NULL, realtek_init, realtek_post },
+
+	{ NULL, 0 }
+};
+
+static struct uart_t * get_by_id(int m_id, int p_id)
+{
+	int i;
+	for (i = 0; uart[i].type; i++) {
+		if (uart[i].m_id == m_id && uart[i].p_id == p_id)
+			return &uart[i];
+	}
+	return NULL;
+}
+
+static struct uart_t * get_by_type(char *type)
+{
+	int i;
+	for (i = 0; uart[i].type; i++) {
+		if (!strcmp(uart[i].type, type))
+			return &uart[i];
+	}
+	return NULL;
+}
+
+/* Initialize UART driver */
+static int init_uart(char *dev, struct uart_t *u, int send_break, int raw)
+{
+	struct termios ti;
+	int fd, i;
+	unsigned long flags = 0;
+
+	if (raw)
+		flags |= 1 << HCI_UART_RAW_DEVICE;
+
+	fd = open(dev, O_RDWR | O_NOCTTY);
+	if (fd < 0) {
+		RS_ERR("Can't open serial port, %d, %s", errno,
+		       strerror(errno));
+		return -1;
+	}
+
+	tcflush(fd, TCIOFLUSH);
+
+	if (tcgetattr(fd, &ti) < 0) {
+		RS_ERR("Can't get port settings, %d, %s", errno,
+		       strerror(errno));
+		return -1;
+	}
+
+	cfmakeraw(&ti);
+
+	ti.c_cflag |= CLOCAL;
+	if (u->flags & FLOW_CTL)
+		ti.c_cflag |= CRTSCTS;
+	else
+		ti.c_cflag &= ~CRTSCTS;
+
+	if (tcsetattr(fd, TCSANOW, &ti) < 0) {
+		RS_ERR("Can't set port settings, %d, %s", errno,
+		       strerror(errno));
+		return -1;
+	}
+
+	/* Set initial baudrate */
+	if (set_speed(fd, &ti, u->init_speed) < 0) {
+		RS_ERR("Can't set initial baud rate, %d, %s", errno,
+		       strerror(errno));
+		return -1;
+	}
+
+	tcflush(fd, TCIOFLUSH);
+
+	if (send_break) {
+		tcsendbreak(fd, 0);
+		usleep(500000);
+	}
+
+	if (u->init && u->init(fd, u, &ti) < 0)
+		return -1;
+
+	tcflush(fd, TCIOFLUSH);
+
+	/* Set actual baudrate
+	 * There is no need to change baudrate after uart init
+	 * */
+	/* if (set_speed(fd, &ti, u->speed) < 0) {
+	 * 	perror("Can't set baud rate");
+	 * 	return -1;
+	 * }
+	 */
+
+	/* Set TTY to N_HCI line discipline */
+	i = N_HCI;
+	if (ioctl(fd, TIOCSETD, &i) < 0) {
+		RS_ERR("Can't set line discipline %d, %s", errno,
+		       strerror(errno));
+		return -1;
+	}
+
+	if (flags && ioctl(fd, HCIUARTSETFLAGS, flags) < 0) {
+		RS_ERR("Can't set UART flags %d, %s", errno, strerror(errno));
+		return -1;
+	}
+
+	if (ioctl(fd, HCIUARTSETPROTO, u->proto) < 0) {
+		RS_ERR("Can't set device %d, %s", errno, strerror(errno));
+		return -1;
+	}
+
+	if (u->post && u->post(fd, u, &ti) < 0)
+		return -1;
+
+	return fd;
+}
+
+static int reset_bluetooth(void)
+{
+
+	int fd;
+	char state[2];
+	int result;
+
+	/* power off and power on BT */
+	fd = open(RFKILL_NODE, O_RDWR);
+	if (fd < 0) {
+		RS_ERR("Cannot open %s, %d %s", RFKILL_NODE, errno,
+				strerror(errno));
+		return -1;
+	}
+	state[0] = '0';
+	state[1] = '\0';
+	result = write(fd, state, strlen(state) + 1);
+	if (result != (strlen(state) + 1)) {
+		RS_ERR("Cannot write 0 to rfkill state %d %s", errno,
+				strerror(errno));
+		close(fd);
+		return -1;
+	}
+
+	usleep(500000);
+
+	state[0] = '1';
+	state[1] = '\0';
+	result = write(fd, state, strlen(state) + 1);
+	if (result != (strlen(state) + 1)) {
+		RS_ERR("Cannot write 1 to rfkill state %d %s", errno,
+				strerror(errno));
+		close(fd);
+		return -1;
+	}
+
+	usleep(500000);
+	close(fd);
+
+	return 0;
+}
+
+static void usage(void)
+{
+	RS_INFO("hciattach - HCI UART driver initialization utility");
+	RS_INFO("Usage:");
+	RS_INFO("\thciattach [-n] [-p] [-b] [-r] [-t timeout] [-s initial_speed] <tty> <type | id> [speed] [flow|noflow] [bdaddr]");
+	RS_INFO("\thciattach -l");
+}
+
+int main(int argc, char *argv[])
+{
+	struct uart_t *u = NULL;
+	int detach, printpid, raw, opt, i, n, ld, err;
+	int to = 10;
+	int init_speed = 0;
+	int send_break = 0;
+	pid_t pid;
+	struct sigaction sa;
+	struct pollfd p;
+	sigset_t sigs;
+	char dev[PATH_MAX];
+#ifdef SCHED_ENABLE
+	struct sched_param sched_par;
+#endif
+
+	detach = 1;
+	printpid = 0;
+	raw = 0;
+
+	while ((opt=getopt(argc, argv, "bnpt:s:lr")) != EOF) {
+		switch(opt) {
+		case 'b':
+			send_break = 1;
+			break;
+
+		case 'n':
+			detach = 0;
+			break;
+
+		case 'p':
+			printpid = 1;
+			break;
+
+		case 't':
+			to = atoi(optarg);
+			break;
+
+		case 's':
+			init_speed = atoi(optarg);
+			break;
+
+		case 'l':
+			for (i = 0; uart[i].type; i++) {
+				RS_INFO("%-10s0x%04x,0x%04x", uart[i].type,
+							uart[i].m_id, uart[i].p_id);
+			}
+			exit(0);
+
+		case 'r':
+			raw = 1;
+			break;
+
+		default:
+			usage();
+			exit(1);
+		}
+	}
+
+	n = argc - optind;
+	if (n < 2) {
+		usage();
+		exit(1);
+	}
+
+	for (n = 0; optind < argc; n++, optind++) {
+		char *opt;
+
+		opt = argv[optind];
+
+		switch(n) {
+		case 0:
+			dev[0] = 0;
+			if (!strchr(opt, '/'))
+				strcpy(dev, "/dev/");
+			strcat(dev, opt);
+			break;
+
+		case 1:
+			if (strchr(argv[optind], ',')) {
+				int m_id, p_id;
+				sscanf(argv[optind], "%x,%x", &m_id, &p_id);
+				u = get_by_id(m_id, p_id);
+			} else {
+				u = get_by_type(opt);
+			}
+
+			if (!u) {
+				RS_ERR("Unknown device type or id");
+				exit(1);
+			}
+
+			break;
+
+		case 2:
+			u->speed = atoi(argv[optind]);
+			break;
+
+		case 3:
+			if (!strcmp("flow", argv[optind]))
+				u->flags |=  FLOW_CTL;
+			else
+				u->flags &= ~FLOW_CTL;
+			break;
+
+		case 4:
+			if (!strcmp("sleep", argv[optind]))
+				u->pm = ENABLE_PM;
+			else
+				u->pm = DISABLE_PM;
+			break;
+
+		case 5:
+			u->bdaddr = argv[optind];
+			break;
+		}
+	}
+
+	if (!u) {
+		RS_ERR("Unknown device type or id");
+		exit(1);
+	}
+
+start:
+
+#ifdef SCHED_ENABLE
+	RS_INFO("Increase the priority of the process with set sched");
+	memset(&sched_par, 0, sizeof(sched_par));
+	sched_par.sched_priority = 99;
+	err = sched_setscheduler(0, SCHED_FIFO, &sched_par);
+	if (err == -1) {
+		RS_ERR("Call sched_setscheduler error, %s",
+			strerror(errno));
+	}
+/* #else
+ * 	RS_INFO("Increase the priority of the process with nice");
+ * 	err = nice(-20);
+ * 	if (err == -1) {
+ * 		RS_ERR("Call nice error, %s", strerror(errno));
+ * 	}
+ */
+#endif
+
+	/* If user specified a initial speed, use that instead of
+	   the hardware's default */
+	if (init_speed)
+		u->init_speed = init_speed;
+
+	memset(&sa, 0, sizeof(sa));
+	sa.sa_flags   = SA_NOCLDSTOP;
+	sa.sa_handler = sig_alarm;
+	sigaction(SIGALRM, &sa, NULL);
+
+	/* 10 seconds should be enough for initialization */
+	alarm(to);
+
+	n = init_uart(dev, u, send_break, raw);
+	if (n < 0) {
+		RS_ERR("Can't initialize device %d, %s", errno,
+		       strerror(errno));
+		exit(1);
+	}
+
+	RS_INFO("Device setup complete");
+
+	alarm(0);
+
+	memset(&sa, 0, sizeof(sa));
+	sa.sa_flags   = SA_NOCLDSTOP;
+	sa.sa_handler = SIG_IGN;
+	sigaction(SIGCHLD, &sa, NULL);
+	sigaction(SIGPIPE, &sa, NULL);
+
+	sa.sa_handler = sig_term;
+	sigaction(SIGTERM, &sa, NULL);
+	sigaction(SIGINT,  &sa, NULL);
+
+	sa.sa_handler = sig_hup;
+	sigaction(SIGHUP, &sa, NULL);
+
+	if (detach) {
+		if ((pid = fork())) {
+			if (printpid)
+				RS_INFO("%d", pid);
+			return 0;
+		}
+
+		for (i = 0; i < 20; i++)
+			if (i != n)
+				close(i);
+	}
+
+	p.fd = n;
+	p.events = POLLERR | POLLHUP;
+
+	sigfillset(&sigs);
+	sigdelset(&sigs, SIGCHLD);
+	sigdelset(&sigs, SIGPIPE);
+	sigdelset(&sigs, SIGTERM);
+	sigdelset(&sigs, SIGINT);
+	sigdelset(&sigs, SIGHUP);
+
+	while (!__io_canceled) {
+		p.revents = 0;
+		err = ppoll(&p, 1, NULL, &sigs);
+		if (err < 0 && errno == EINTR) {
+			RS_INFO("Got EINTR.");
+			continue;
+		} if (err)
+			break;
+	}
+
+	RS_INFO("err %d, p->revents %04x", err, p.revents);
+
+	/* Restore TTY line discipline */
+	RS_INFO("Restore TTY line discipline");
+	ld = N_TTY;
+	if (ioctl(n, TIOCSETD, &ld) < 0) {
+		RS_ERR("Can't restore line discipline %d, %s", errno,
+		       strerror(errno));
+		exit(1);
+	}
+
+	if (p.revents & (POLLERR | POLLHUP)) {
+		RS_INFO("Recover...");
+		reset_bluetooth();
+		goto start;
+	}
+
+	return 0;
+}
+
+void util_hexdump(const uint8_t *buf, size_t len)
+{
+	static const char hexdigits[] = "0123456789abcdef";
+	char str[16 * 3];
+	size_t i;
+
+	if (!buf || !len)
+		return;
+
+	for (i = 0; i < len; i++) {
+		str[((i % 16) * 3)] = hexdigits[buf[i] >> 4];
+		str[((i % 16) * 3) + 1] = hexdigits[buf[i] & 0xf];
+		str[((i % 16) * 3) + 2] = ' ';
+		if ((i + 1) % 16 == 0) {
+			str[16 * 3 - 1] = '\0';
+			RS_INFO("%s", str);
+		}
+	}
+
+	if (i % 16 > 0) {
+		str[(i % 16) * 3 - 1] = '\0';
+		RS_INFO("%s", str);
+	}
+}
+
+int timeout_set(int fd, unsigned int msec)
+{
+	struct itimerspec itimer;
+	unsigned int sec = msec / 1000;
+
+	memset(&itimer, 0, sizeof(itimer));
+	itimer.it_interval.tv_sec = 0;
+	itimer.it_interval.tv_nsec = 0;
+	itimer.it_value.tv_sec = sec;
+	itimer.it_value.tv_nsec = (msec - (sec * 1000)) * 1000 * 1000;
+
+	return timerfd_settime(fd, 0, &itimer, NULL);
+}
+
diff --git a/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach.h b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach.h
new file mode 100644
index 0000000..89909c4
--- /dev/null
+++ b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach.h
@@ -0,0 +1,188 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2003-2009  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <termios.h>
+#include <stdint.h>
+#include <syslog.h>
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define cpu_to_le16(d)  (d)
+#define cpu_to_le32(d)  (d)
+#define le16_to_cpu(d)  (d)
+#define le32_to_cpu(d)  (d)
+#elif __BYTE_ORDER == __BIG_ENDIAN
+#define cpu_to_le16(d)  bswap_16(d)
+#define cpu_to_le32(d)  bswap_32(d)
+#define le16_to_cpu(d)  bswap_16(d)
+#define le32_to_cpu(d)  bswap_32(d)
+#else
+#error "Unknown byte order"
+#endif
+
+#ifndef N_HCI
+#define N_HCI	15
+#endif
+
+#define HCIUARTSETPROTO		_IOW('U', 200, int)
+#define HCIUARTGETPROTO		_IOR('U', 201, int)
+#define HCIUARTGETDEVICE	_IOR('U', 202, int)
+#define HCIUARTSETFLAGS		_IOW('U', 203, int)
+#define HCIUARTGETFLAGS		_IOR('U', 204, int)
+
+#define HCI_UART_H4	0
+#define HCI_UART_BCSP	1
+#define HCI_UART_3WIRE	2
+#define HCI_UART_H4DS	3
+#define HCI_UART_LL	4
+#define HCI_UART_RAW_DEVICE	0
+
+extern uint8_t DBG_ON;
+
+/* #define SYSLOG */
+
+#define LOG_STR     "Realtek Bluetooth"
+#ifdef SYSLOG
+#define RS_DBG(fmt, arg...) \
+    do{ \
+        if (DBG_ON) \
+            syslog(LOG_DEBUG, "%s :" fmt "\n" , LOG_STR, ##arg); \
+    }while(0)
+
+#define RS_INFO(fmt, arg...) \
+    do{ \
+        syslog(LOG_INFO, "%s :" fmt "\n", LOG_STR, ##arg); \
+    }while(0)
+
+#define RS_WARN(fmt, arg...) \
+    do{ \
+        syslog(LOG_WARNING, "%s WARN: " fmt "\n", LOG_STR, ##arg); \
+    }while(0)
+
+#define RS_ERR(fmt, arg...) \
+    do{ \
+        syslog(LOG_ERR, "%s ERROR: " fmt "\n", LOG_STR, ##arg); \
+    }while(0)
+#else
+#define RS_DBG(fmt, arg...) \
+    do{ \
+        if (DBG_ON) \
+            printf("%s :" fmt "\n" , LOG_STR, ##arg); \
+    }while(0)
+
+#define RS_INFO(fmt, arg...) \
+    do{ \
+        printf("%s :" fmt "\n", LOG_STR, ##arg); \
+    }while(0)
+
+#define RS_WARN(fmt, arg...) \
+    do{ \
+        printf("%s WARN: " fmt "\n", LOG_STR, ##arg); \
+    }while(0)
+
+#define RS_ERR(fmt, arg...) \
+    do{ \
+        printf("%s ERROR: " fmt "\n", LOG_STR, ##arg); \
+    }while(0)
+#endif
+
+typedef enum _H5_RX_STATE {
+	H5_W4_PKT_DELIMITER,
+	H5_W4_PKT_START,
+	H5_W4_HDR,
+	H5_W4_DATA,
+	H5_W4_CRC
+} H5_RX_STATE;
+
+typedef enum _H5_RX_ESC_STATE {
+	H5_ESCSTATE_NOESC,
+	H5_ESCSTATE_ESC
+} H5_RX_ESC_STATE;
+
+typedef enum _H5_LINK_STATE {
+	H5_SYNC,
+	H5_CONFIG,
+	H5_INIT,
+	H5_PATCH,
+	H5_HCI_RESET,
+	H5_ACTIVE
+} H5_LINK_STATE;
+
+struct patch_info;
+typedef struct rtb_struct {
+	/* three wire releated */
+	uint8_t rxseq_txack;	/* expected rx seq number */
+	uint8_t rxack;		/* last packet that the peer ack'ed */
+	uint8_t use_crc;
+	uint8_t is_txack_req;	/* txack required */
+	uint8_t msgq_txseq;	/* next pkt seq */
+	uint16_t message_crc;
+	uint32_t rx_count;	/* expected pkts to recv */
+
+	H5_RX_STATE rx_state;
+	H5_RX_ESC_STATE rx_esc_state;
+	H5_LINK_STATE link_estab_state;
+
+	struct sk_buff *rx_skb;
+
+	uint16_t num_of_cmd_sent;
+	uint16_t lmp_subver;
+	uint16_t hci_rev;
+	uint8_t hci_ver;
+	uint8_t eversion;
+	uint8_t chip_type;
+
+	uint32_t vendor_baud;
+	uint8_t dl_fw_flag;
+	int serial_fd;
+	int uart_flow_ctrl;
+	uint32_t parenb:   16;
+	uint32_t pareven: 16;
+	int final_speed;
+	int total_num;	/* total pkt number */
+	int tx_index;	/* current sending pkt number */
+	int rx_index;	/* ack index from board */
+	int fw_len;	/* fw patch file len */
+	int config_len;	/* config patch file len */
+	int total_len;	/* fw & config extracted buf len */
+	uint8_t *fw_buf;	/* fw patch file buf */
+	uint8_t *config_buf;	/* config patch file buf */
+	uint8_t *total_buf;	/* fw & config extracted buf */
+#define CMD_STATE_UNKNOWN	0x00
+#define CMD_STATE_SUCCESS	0x01
+	struct __cmd_state {
+		uint16_t opcode;
+		uint16_t state;
+	} cmd_state;
+
+	struct patch_info *patch_ent;
+
+	int proto;
+	int timerfd;
+	int epollfd;
+} rtb_struct_t;
+extern struct rtb_struct rtb_cfg;
+int timeout_set(int fd, unsigned int msec);
+int set_speed(int fd, struct termios *ti, int speed);
+int rtb_init(int fd, int proto, int speed, struct termios *ti);
+int rtb_post(int fd, int proto, struct termios *ti);
+void util_hexdump(const uint8_t *buf, size_t len);
diff --git a/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach_h4.c b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach_h4.c
new file mode 100644
index 0000000..ae92395
--- /dev/null
+++ b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach_h4.c
@@ -0,0 +1,295 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <termios.h>
+#include <time.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <stdint.h>
+#include <string.h>
+#include <endian.h>
+#include <byteswap.h>
+#include <netinet/in.h>
+#include <ctype.h>
+#include <poll.h>
+#include <sys/timerfd.h>
+#include <sys/epoll.h>
+#include "hciattach.h"
+#include "hciattach_h4.h"
+
+extern struct rtb_struct rtb_cfg;
+
+static int start_xfer_wait(int fd, uint8_t *cmd, uint16_t len, uint32_t msec,
+			   int retry, uint8_t *resp, uint16_t *resp_len)
+{
+	uint8_t buf[64];
+	int result;
+	int state = 1;
+	int count = 0;
+	int params_len;
+	struct pollfd p[2];
+	uint16_t opcode;
+
+	if (fd == -1 || !cmd || len < 4) {
+		RS_ERR("%s: invalid parameter", __func__);
+		return -1;
+	}
+
+	opcode = ((uint16_t)cmd[2] << 8) + cmd[1];
+
+start_xfer:
+	result = write(fd, cmd, len);
+	if (result != len) {
+		RS_ERR("%s: Write cmd %04x error, %s", __func__, opcode,
+		       strerror(errno));
+		return -1;
+	}
+
+start_recv:
+	memset(buf, 0, sizeof(buf));
+	memset(p, 0, sizeof(p));
+	state = 1;
+	count = 0;
+	p[0].fd = fd;
+	p[0].events = POLLERR | POLLHUP | POLLIN;
+	for (;;) {
+		p[0].revents = 0;
+		result = poll(p, 1, msec);
+		if (result < 0) {
+			RS_ERR("Poll call error, %s", strerror(errno));
+			result = -1;
+			break;
+		}
+
+		if (result == 0) {
+			RS_WARN("%s: Timeout", __func__);
+			if (retry <= 0) {
+				RS_ERR("%s: Transfer exhausted", __func__);
+				tcflush(fd, TCIOFLUSH);
+				exit(EXIT_FAILURE);
+			}
+			retry--;
+			goto start_xfer;
+		}
+
+		if (p[0].revents & (POLLERR | POLLHUP)) {
+			RS_ERR("POLLERR or POLLUP happens, %s",
+			       strerror(errno));
+			result = -1;
+			break;
+		}
+
+		if (state == 1) {
+			result = read(p[0].fd, buf, 1);
+			if (result == -1 || result != 1) {
+				RS_ERR("%s: Read pkt type error, %s", __func__,
+				       strerror(errno));
+				result = -1;
+				break;
+			}
+			if (result == 1 && buf[0] == 0x04) {
+				count = 1;
+				state = 2;
+			}
+		} else if (state == 2) {
+			result = read(p[0].fd, buf + count, 2);
+			if (result == -1 || result != 2) {
+				RS_ERR("%s: Read pkt header error, %s",
+				       __func__, strerror(errno));
+				break;
+			}
+			count += result;
+			state = 3;
+			params_len = buf[2];
+			if (params_len + 3 > sizeof(buf)) {
+				result = -1;
+				RS_ERR("%s: hci event too long", __func__);
+				break;
+			}
+		} else if (state == 3) {
+			result = read(p[0].fd, buf + count, params_len);
+			if (result == -1) {
+				RS_ERR("%s: Read pkt payload error, %s",
+				       __func__, strerror(errno));
+				break;
+			}
+			count += result;
+			params_len -= result;
+			if (!params_len)
+				break;
+		}
+	}
+
+	if (result >= 0) {
+		if (buf[1] == 0x0e) {
+			uint16_t tmp_opcode;
+
+			tmp_opcode = (uint16_t)buf[4] | buf[5] << 8;
+			if (tmp_opcode == opcode) {
+				RS_INFO("Cmd complete event for cmd %04x",
+					opcode);
+				/* Status is not zero indicating command not
+				 * succeeded */
+				if (buf[6])
+					return -1;
+				if (!resp)
+					return 0;
+				if (*resp_len > count)
+					*resp_len = count;
+				memcpy(resp, buf, *resp_len);
+				return 0;
+			} else {
+				RS_WARN("Unexpected cmd complete event, %04x",
+					tmp_opcode);
+				return -1;
+			}
+		} else {
+			RS_INFO("%s: Unexpected hci event packet", __func__);
+			util_hexdump(buf, count);
+			/* Continue receiving */
+		}
+		goto start_recv;
+	}
+
+	return result;
+}
+
+int h4_download_patch(int fd, int index, uint8_t *data, int len)
+{
+	uint8_t buf[257];
+	uint16_t total_len;
+	int result;
+	uint8_t resp[8];
+	uint16_t rlen = sizeof(resp);
+
+	RS_DBG("fd: %d, index: %d, len: %d", fd, index, len);
+
+	if (data)
+		memcpy(&buf[5], data, len);
+	buf[0] = 0x01;
+	buf[1] = 0x20;
+	buf[2] = 0xfc;
+	buf[3] = len + 1;
+	buf[4] = (uint8_t)index;
+	total_len = len + 5;
+
+	result = start_xfer_wait(fd, buf, total_len, 1000, 0, resp, &rlen);
+	if (result < 0) {
+		RS_ERR("Transfer patch failed, index %d", index);
+		return -1;
+	}
+
+	if (rlen != 8) {
+		RS_ERR("%s: Unexpected length %u", __func__, rlen);
+		return -1;
+	}
+
+	return resp[7];
+}
+
+int h4_vendor_change_speed(int fd, uint32_t baudrate)
+{
+	int res;
+	uint8_t cmd[8] = { 0 };
+
+	cmd[0] = 1;
+	cmd[1] = 0x17;
+	cmd[2] = 0xfc;
+	cmd[3] = 4;
+
+	baudrate = cpu_to_le32(baudrate);
+#ifdef BAUDRATE_4BYTES
+	memcpy((uint16_t *) & cmd[4], &baudrate, 4);
+#else
+	memcpy((uint16_t *) & cmd[4], &baudrate, 2);
+	cmd[6] = 0;
+	cmd[7] = 0;
+#endif
+
+	/* TODO: Wait for a while for device to up, just h4 need it */
+	sleep(1);
+
+	RS_DBG("baudrate in change speed command: 0x%02x 0x%02x 0x%02x 0x%02x",
+	       cmd[4], cmd[5], cmd[6], cmd[7]);
+
+	res = start_xfer_wait(fd, cmd, 8, 1000, 0, NULL, 0);
+	if (res < 0)
+		RS_ERR("Change Controller baud failed");
+
+	return res;
+}
+
+int h4_hci_reset(int fd)
+{
+	int result;
+	uint8_t cmd[4] = { 0x01, 0x03, 0x0c, 0x00};
+
+	RS_INFO("%s: Issue hci reset cmd", __func__);
+
+	result = start_xfer_wait(fd, cmd, sizeof(cmd), 1000, 0, NULL, 0);
+	if (result < 0) {
+		RS_ERR("%s: Failed to send reset cmd", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+int h4_read_local_ver(int fd)
+{
+	uint8_t cmd[4] = { 0x01, 0x01, 0x10, 0x00 };
+	uint8_t resp[16];
+	uint16_t len = sizeof(resp);
+	int result;
+
+	result = start_xfer_wait(fd, cmd, sizeof(cmd), 1000, 0,
+				 resp, &len);
+	if (result < 0) {
+		RS_ERR("HCI Read local version info error");
+		return -1;
+	}
+
+	if (len != 15) {
+		RS_ERR("%s: Unexpected length %u", __func__, len);
+		return -1;
+	}
+	rtb_cfg.hci_ver = resp[7];
+	rtb_cfg.hci_rev = (uint32_t)resp[9] << 8 | resp[8];
+	rtb_cfg.lmp_subver = (uint32_t)resp[14] << 8 | resp[13];
+	RS_INFO("hci ver %02x, hci_rev %04x, lmp_subver %04x",
+		rtb_cfg.hci_ver, rtb_cfg.hci_rev, rtb_cfg.lmp_subver);
+	return 0;
+}
+
+int h4_vendor_read_rom_ver(int fd)
+{
+	uint8_t cmd[4] = { 0x01, 0x6d, 0xfc, 0x00 };
+	uint8_t resp[16];
+	uint16_t len = sizeof(resp);
+	int result;
+
+	result = start_xfer_wait(fd, cmd, sizeof(cmd), 1000, 0,
+				 resp, &len);
+	if (result < 0) {
+		RS_ERR("HCI Read local version info error");
+		return -1;
+	}
+
+	if (len != 8) {
+		RS_ERR("%s: Unexpected length %u", __func__, len);
+		return -1;
+	}
+	rtb_cfg.eversion = resp[7];
+	RS_INFO("eversion %02x", rtb_cfg.eversion);
+	return 0;
+}
+
diff --git a/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach_h4.h b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach_h4.h
new file mode 100644
index 0000000..8549da7
--- /dev/null
+++ b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach_h4.h
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <stdint.h>
+int h4_download_patch(int fd, int index, uint8_t *data, int len);
+int h4_vendor_change_speed(int fd, uint32_t baudrate);
+int h4_hci_reset(int fd);
+int h4_read_local_ver(int fd);
+int h4_vendor_read_rom_ver(int fd);
diff --git a/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach_rtk.c b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach_rtk.c
new file mode 100644
index 0000000..11e5e01
--- /dev/null
+++ b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/hciattach_rtk.c
@@ -0,0 +1,2024 @@
+/*
+ *  Copyright (C) 2013 Realtek Semiconductor Corp.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <termios.h>
+#include <time.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <stdint.h>
+#include <string.h>
+#include <endian.h>
+#include <byteswap.h>
+#include <netinet/in.h>
+#include <poll.h>
+#include <sys/timerfd.h>
+#include <sys/epoll.h>
+
+#include "rtb_fwc.h"
+#include "hciattach.h"
+#include "hciattach_h4.h"
+
+#define RTK_VERSION "3.1.a2a2042.20191024-161739"
+
+#define TIMESTAMP_PR
+
+#define MAX_EVENTS 10
+
+/* #define SERIAL_NONBLOCK_READ */
+
+#ifdef SERIAL_NONBLOCK_READ
+#define FD_BLOCK	0
+#define FD_NONBLOCK	1
+#endif
+
+/* #define RTL_8703A_SUPPORT */
+/* #define RTL8723DSH4_UART_HWFLOWC */ /* 8723DS H4 special */
+
+uint8_t DBG_ON = 1;
+
+#define HCI_EVENT_HDR_SIZE          2
+/* #define RTK_PATCH_LENGTH_MAX        24576	*/ //24*1024
+#define RTB_PATCH_LENGTH_MAX        (40 * 1024)
+#define PATCH_DATA_FIELD_MAX_SIZE   252
+
+#define HCI_CMD_READ_BD_ADDR		0x1009
+#define HCI_VENDOR_CHANGE_BAUD		0xfc17
+#define HCI_VENDOR_READ_ROM_VER		0xfc6d
+#define HCI_CMD_READ_LOCAL_VER		0x1001
+#define HCI_VENDOR_READ_CHIP_TYPE	0xfc61
+#define HCI_CMD_RESET			0x0c03
+
+/* HCI data types */
+#define H5_ACK_PKT              0x00
+#define HCI_COMMAND_PKT         0x01
+#define HCI_ACLDATA_PKT         0x02
+#define HCI_SCODATA_PKT         0x03
+#define HCI_EVENT_PKT           0x04
+#define H5_VDRSPEC_PKT          0x0E
+#define H5_LINK_CTL_PKT         0x0F
+
+#define H5_HDR_SEQ(hdr)         ((hdr)[0] & 0x07)
+#define H5_HDR_ACK(hdr)         (((hdr)[0] >> 3) & 0x07)
+#define H5_HDR_CRC(hdr)         (((hdr)[0] >> 6) & 0x01)
+#define H5_HDR_RELIABLE(hdr)    (((hdr)[0] >> 7) & 0x01)
+#define H5_HDR_PKT_TYPE(hdr)    ((hdr)[1] & 0x0f)
+#define H5_HDR_LEN(hdr)         ((((hdr)[1] >> 4) & 0xff) + ((hdr)[2] << 4))
+#define H5_HDR_SIZE             4
+
+struct sk_buff {
+	uint32_t max_len;
+	uint32_t data_len;
+	uint8_t *data;
+};
+
+struct hci_ev_cmd_complete {
+	uint8_t ncmd;
+	uint16_t opcode;
+} __attribute__ ((packed));
+
+#define OP_H5_SYNC		0x01
+#define OP_H5_CONFIG		0x02
+#define OP_ROM_VER		((1 << 24) | HCI_VENDOR_READ_ROM_VER)
+#define OP_LMP_VER		((1 << 24) | HCI_CMD_READ_LOCAL_VER)
+#define OP_CHIP_TYPE		((1 << 24) | HCI_VENDOR_READ_CHIP_TYPE)
+#define OP_SET_BAUD		((1 << 24) | HCI_VENDOR_CHANGE_BAUD)
+#define OP_HCI_RESET		((1 << 24) | HCI_CMD_RESET)
+
+struct rtb_struct rtb_cfg;
+
+/* bite reverse in bytes
+ * 00000001 -> 10000000
+ * 00000100 -> 00100000
+ */
+const uint8_t byte_rev_table[256] = {
+	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
+	0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
+	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
+	0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
+	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
+	0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
+	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
+	0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
+	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
+	0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
+	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
+	0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
+	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
+	0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
+	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
+	0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
+	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
+	0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
+	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
+	0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
+	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
+	0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
+	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
+	0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
+	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
+	0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
+	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
+	0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
+	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
+	0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
+	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
+	0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
+};
+
+static __inline uint8_t bit_rev8(uint8_t byte)
+{
+	return byte_rev_table[byte];
+}
+
+static __inline uint16_t bit_rev16(uint16_t x)
+{
+	return (bit_rev8(x & 0xff) << 8) | bit_rev8(x >> 8);
+}
+
+static const uint16_t crc_table[] = {
+	0x0000, 0x1081, 0x2102, 0x3183,
+	0x4204, 0x5285, 0x6306, 0x7387,
+	0x8408, 0x9489, 0xa50a, 0xb58b,
+	0xc60c, 0xd68d, 0xe70e, 0xf78f
+};
+
+/* Initialise the crc calculator */
+#define H5_CRC_INIT(x) x = 0xffff
+
+static __inline struct sk_buff *skb_alloc(unsigned int len)
+{
+	struct sk_buff *skb = NULL;
+
+	if ((skb = malloc(len + sizeof(*skb)))) {
+		skb->max_len = len;
+		skb->data_len = 0;
+		skb->data = ((uint8_t *)skb) + sizeof(*skb);
+	} else {
+		RS_ERR("Allocate skb fails!");
+		skb = NULL;
+		return NULL;
+	}
+	memset(skb->data, 0, len);
+	return skb;
+}
+
+static __inline void skb_free(struct sk_buff *skb)
+{
+	free(skb);
+	return;
+}
+
+/*
+ * Add data to a buffer
+ * This function extends the used data area of the buffer.
+ */
+static uint8_t *skb_put(struct sk_buff *skb, uint32_t len)
+{
+	uint32_t old_len = skb->data_len;
+
+	if ((skb->data_len + len) > (skb->max_len)) {
+		RS_ERR("Buffer too small");
+		exit(EXIT_FAILURE);
+	}
+	skb->data_len += len;
+	return (skb->data + old_len);
+}
+
+/*
+ * Remove end from a buffer
+ * Cut the length of a buffer down by removing data from the tail
+ */
+static void skb_trim(struct sk_buff *skb, uint32_t len)
+{
+	if (skb->data_len > len) {
+		skb->data_len = len;
+	} else {
+		RS_ERR("Trim error, data_len %u < len %u", skb->data_len, len);
+	}
+}
+
+/*
+ * Remove data from the start of a buffer
+ * This function removes data from the start of a buffer.
+ * A pointer to the next data in the buffer is returned
+ */
+static uint8_t *skb_pull(struct sk_buff *skb, uint32_t len)
+{
+	if (len > skb->data_len) {
+		RS_ERR("Pull error, data_len %u < len %u", skb->data_len, len);
+		exit(EXIT_FAILURE);
+	}
+	skb->data_len -= len;
+	skb->data += len;
+	return skb->data;
+}
+
+/**
+* Add "d" into crc scope, caculate the new crc value
+*
+* @param crc crc data
+* @param d one byte data
+*/
+static void h5_crc_update(uint16_t * crc, uint8_t d)
+{
+	uint16_t reg = *crc;
+
+	reg = (reg >> 4) ^ crc_table[(reg ^ d) & 0x000f];
+	reg = (reg >> 4) ^ crc_table[(reg ^ (d >> 4)) & 0x000f];
+
+	*crc = reg;
+}
+
+struct __una_u16 {
+	uint16_t x;
+};
+static __inline uint16_t __get_unaligned_cpu16(const void *p)
+{
+	const struct __una_u16 *ptr = (const struct __una_u16 *)p;
+	return ptr->x;
+}
+
+static __inline uint16_t get_unaligned_be16(const void *p)
+{
+	return __get_unaligned_cpu16((const uint8_t *)p);
+}
+
+/*
+ * Get crc data.
+ */
+static uint16_t h5_get_crc(struct rtb_struct * h5)
+{
+	uint16_t crc = 0;
+	uint8_t *data = h5->rx_skb->data + h5->rx_skb->data_len - 2;
+
+	crc = data[1] + (data[0] << 8);
+	return crc;
+	/* return get_unaligned_be16(&h5->rx_skb->data[h5->rx_skb->data_len - 2]); */
+}
+
+/*
+ * Add 0xc0 to buffer.
+ */
+static void h5_slip_msgdelim(struct sk_buff *skb)
+{
+	const char pkt_delim = 0xc0;
+	memcpy(skb_put(skb, 1), &pkt_delim, 1);
+}
+
+/*
+ * Encode one byte in h5 proto
+ * 0xc0 -> 0xdb, 0xdc
+ * 0xdb -> 0xdb, 0xdd
+ * 0x11 -> 0xdb, 0xde
+ * 0x13 -> 0xdb, 0xdf
+ * others will not change
+ */
+static void h5_slip_one_byte(struct sk_buff *skb, uint8_t c)
+{
+	const uint8_t esc_c0[2] = { 0xdb, 0xdc };
+	const uint8_t esc_db[2] = { 0xdb, 0xdd };
+	const uint8_t esc_11[2] = { 0xdb, 0xde };
+	const uint8_t esc_13[2] = { 0xdb, 0xdf };
+
+	switch (c) {
+	case 0xc0:
+		memcpy(skb_put(skb, 2), &esc_c0, 2);
+		break;
+
+	case 0xdb:
+		memcpy(skb_put(skb, 2), &esc_db, 2);
+		break;
+
+	case 0x11:
+		memcpy(skb_put(skb, 2), &esc_11, 2);
+		break;
+
+	case 0x13:
+		memcpy(skb_put(skb, 2), &esc_13, 2);
+		break;
+
+	default:
+		memcpy(skb_put(skb, 1), &c, 1);
+		break;
+	}
+}
+
+/*
+ * Decode one byte in h5 proto
+ * 0xdb, 0xdc -> 0xc0
+ * 0xdb, 0xdd -> 0xdb
+ * 0xdb, 0xde -> 0x11
+ * 0xdb, 0xdf -> 0x13
+ * others will not change
+ */
+static void h5_unslip_one_byte(struct rtb_struct * h5, unsigned char byte)
+{
+	const uint8_t c0 = 0xc0, db = 0xdb;
+	const uint8_t oof1 = 0x11, oof2 = 0x13;
+
+	if (H5_ESCSTATE_NOESC == h5->rx_esc_state) {
+		if (0xdb == byte) {
+			h5->rx_esc_state = H5_ESCSTATE_ESC;
+		} else {
+			memcpy(skb_put(h5->rx_skb, 1), &byte, 1);
+			/* Check Pkt Header's CRC enable bit */
+			if ((h5->rx_skb->data[0] & 0x40) != 0 &&
+			    h5->rx_state != H5_W4_CRC) {
+				h5_crc_update(&h5->message_crc, byte);
+			}
+			h5->rx_count--;
+		}
+	} else if (H5_ESCSTATE_ESC == h5->rx_esc_state) {
+		switch (byte) {
+		case 0xdc:
+			memcpy(skb_put(h5->rx_skb, 1), &c0, 1);
+			if ((h5->rx_skb->data[0] & 0x40) != 0 &&
+			    h5->rx_state != H5_W4_CRC)
+				h5_crc_update(&h5->message_crc, 0xc0);
+			h5->rx_esc_state = H5_ESCSTATE_NOESC;
+			h5->rx_count--;
+			break;
+
+		case 0xdd:
+			memcpy(skb_put(h5->rx_skb, 1), &db, 1);
+			if ((h5->rx_skb->data[0] & 0x40) != 0 &&
+			    h5->rx_state != H5_W4_CRC)
+				h5_crc_update(&h5->message_crc, 0xdb);
+			h5->rx_esc_state = H5_ESCSTATE_NOESC;
+			h5->rx_count--;
+			break;
+
+		case 0xde:
+			memcpy(skb_put(h5->rx_skb, 1), &oof1, 1);
+			if ((h5->rx_skb->data[0] & 0x40) != 0 &&
+			    h5->rx_state != H5_W4_CRC)
+				h5_crc_update(&h5->message_crc, oof1);
+			h5->rx_esc_state = H5_ESCSTATE_NOESC;
+			h5->rx_count--;
+			break;
+
+		case 0xdf:
+			memcpy(skb_put(h5->rx_skb, 1), &oof2, 1);
+			if ((h5->rx_skb->data[0] & 0x40) != 0 &&
+			    h5->rx_state != H5_W4_CRC)
+				h5_crc_update(&h5->message_crc, oof2);
+			h5->rx_esc_state = H5_ESCSTATE_NOESC;
+			h5->rx_count--;
+			break;
+
+		default:
+			RS_ERR("Error: Invalid byte %02x after esc byte", byte);
+			skb_free(h5->rx_skb);
+			h5->rx_skb = NULL;
+			h5->rx_state = H5_W4_PKT_DELIMITER;
+			h5->rx_count = 0;
+			break;
+		}
+	}
+}
+
+/*
+ * Prepare h5 packet
+ * Refer to Core Spec Vol 4, Part D
+ * Three-wire UART Transport Layer: 4 PACKET HEADER
+ */
+static struct sk_buff *h5_prepare_pkt(struct rtb_struct * h5, uint8_t *data,
+				      int len, int pkt_type)
+{
+	struct sk_buff *nskb;
+	uint8_t hdr[4];
+	uint16_t H5_CRC_INIT(h5_txmsg_crc);
+	int rel, i;
+
+	switch (pkt_type) {
+	case HCI_ACLDATA_PKT:
+	case HCI_COMMAND_PKT:
+	case HCI_EVENT_PKT:
+		rel = 1; /* reliable */
+		break;
+
+	case H5_ACK_PKT:
+	case H5_VDRSPEC_PKT:
+	case H5_LINK_CTL_PKT:
+		rel = 0; /* unreliable */
+		break;
+
+	default:
+		RS_ERR("Unknown packet type");
+		return NULL;
+	}
+
+	/* Max len of packet: (len + 4(h5 hdr) + 2(crc))*2
+	 * Because bytes 0xc0 and 0xdb are escaped, worst case is that the
+	 * packet is only made of 0xc0 and 0xdb
+	 * The additional 2-octets are 0xc0 delimiters at start and end of each
+	 * packet.
+	 */
+	nskb = skb_alloc((len + 6) * 2 + 2);
+	if (!nskb)
+		return NULL;
+
+	/* Add SLIP start byte: 0xc0 */
+	h5_slip_msgdelim(nskb);
+	/* Set ack number in SLIP header */
+	hdr[0] = h5->rxseq_txack << 3;
+	h5->is_txack_req = 0;
+
+	/* RS_DBG("Request packet no(%u) to card", h5->rxseq_txack); */
+	/* RS_DBG("Sending packet with seqno %u and wait %u", h5->msgq_txseq,
+	 *        h5->rxseq_txack);
+	 */
+	if (rel) {
+		/* Set reliable bit and seq number */
+		hdr[0] |= 0x80 + h5->msgq_txseq;
+		/* RS_DBG("Sending packet with seqno(%u)", h5->msgq_txseq); */
+		++(h5->msgq_txseq);
+		h5->msgq_txseq = (h5->msgq_txseq) & 0x07;
+	}
+	/* Set DIC Present bit */
+	if (h5->use_crc)
+		hdr[0] |= 0x40;
+
+	/* Set packet type and payload length */
+	hdr[1] = ((len << 4) & 0xff) | pkt_type;
+	hdr[2] = (uint8_t) (len >> 4);
+	/* Set header checksum */
+	hdr[3] = ~(hdr[0] + hdr[1] + hdr[2]);
+
+	/* Encode h5 header */
+	for (i = 0; i < 4; i++) {
+		h5_slip_one_byte(nskb, hdr[i]);
+
+		if (h5->use_crc)
+			h5_crc_update(&h5_txmsg_crc, hdr[i]);
+	}
+
+	/* Encode payload */
+	for (i = 0; i < len; i++) {
+		h5_slip_one_byte(nskb, data[i]);
+
+		if (h5->use_crc)
+			h5_crc_update(&h5_txmsg_crc, data[i]);
+	}
+
+	/* Encode CRC */
+	if (h5->use_crc) {
+		h5_txmsg_crc = bit_rev16(h5_txmsg_crc);
+		h5_slip_one_byte(nskb, (uint8_t) ((h5_txmsg_crc >> 8) & 0x00ff));
+		h5_slip_one_byte(nskb, (uint8_t) (h5_txmsg_crc & 0x00ff));
+	}
+	/* Add 0xc0 at the end of the packet */
+	h5_slip_msgdelim(nskb);
+
+	return nskb;
+}
+
+/*
+ * Remove controller acked packet from host unacked lists
+ */
+/* static void h5_remove_acked_pkt(struct rtb_struct * h5)
+ * {
+ * 	int pkts_to_be_removed = 0;
+ * 	int seqno = 0;
+ * 	int i = 0;
+ * 
+ * 	seqno = h5->msgq_txseq;
+ * 	// pkts_to_be_removed = GetListLength(h5->unacked);
+ * 
+ * 	while (pkts_to_be_removed) {
+ * 		if (h5->rxack == seqno)
+ * 			break;
+ * 
+ * 		pkts_to_be_removed--;
+ * 		seqno = (seqno - 1) & 0x07;
+ * 	}
+ * 
+ * 	if (h5->rxack != seqno) {
+ * 		RS_DBG("Peer acked invalid packet");
+ * 	}
+ * 	// skb_queue_walk_safe(&h5->unack, skb, tmp)
+ * 	// remove ack'ed packet from h5->unack queue
+ * 	for (i = 0; i < 5; ++i) {
+ * 		if (i >= pkts_to_be_removed)
+ * 			break;
+ * 		i++;
+ * 		//__skb_unlink(skb, &h5->unack);
+ * 		//skb_free(skb);
+ * 	}
+ * 
+ * 	//  if (skb_queue_empty(&h5->unack))
+ * 	//          del_timer(&h5->th5);
+ * 	//  spin_unlock_irqrestore(&h5->unack.lock, flags);
+ * 
+ * 	if (i != pkts_to_be_removed)
+ * 		RS_DBG("Removed only (%u) out of (%u) pkts", i,
+ * 		       pkts_to_be_removed);
+ * }
+ */
+
+/*
+ * Send host ack.
+ */
+static void rtb_send_ack(int fd)
+{
+	int len;
+	struct sk_buff *nskb = h5_prepare_pkt(&rtb_cfg, NULL, 0, H5_ACK_PKT);
+
+	len = write(fd, nskb->data, nskb->data_len);
+	if (len != nskb->data_len)
+		RS_ERR("Write pure ack fails");
+
+	skb_free(nskb);
+	return;
+}
+
+/*
+ * Parse hci command complete event in h5 init state.
+ */
+static void h5_init_hci_cc(struct sk_buff *skb)
+{
+	struct hci_ev_cmd_complete *ev = NULL;
+	uint16_t opcode = 0;
+	uint8_t status = 0;
+
+	skb_pull(skb, HCI_EVENT_HDR_SIZE);
+	ev = (struct hci_ev_cmd_complete *)skb->data;
+	opcode = le16_to_cpu(ev->opcode);
+
+	RS_DBG("Receive cmd complete event of command: %04x", opcode);
+
+	skb_pull(skb, sizeof(struct hci_ev_cmd_complete));
+
+	status = skb->data[0];
+	if (status) {
+		RS_ERR("status is %u for cmd %04x", status, opcode);
+		return;
+	}
+
+	if (rtb_cfg.cmd_state.opcode != opcode) {
+		RS_ERR("%s: Received unexpected cc for cmd %04x, %04x of cc",
+		       __func__, rtb_cfg.cmd_state.opcode, opcode);
+		return;
+	}
+
+	rtb_cfg.cmd_state.state = CMD_STATE_SUCCESS;
+
+	switch (opcode) {
+	case HCI_VENDOR_CHANGE_BAUD:
+		RS_INFO("Received cc of vendor change baud");
+		break;
+	case HCI_CMD_READ_BD_ADDR:
+		RS_INFO("BD Address: %02x:%02x:%02x:%02x:%02x:%02x",
+			skb->data[5], skb->data[4], skb->data[3],
+			skb->data[2], skb->data[1], skb->data[0]);
+		break;
+
+	case HCI_CMD_READ_LOCAL_VER:
+		rtb_cfg.hci_ver = skb->data[1];
+		rtb_cfg.hci_rev = (skb->data[2] | skb->data[3] << 8);
+		rtb_cfg.lmp_subver = (skb->data[7] | (skb->data[8] << 8));
+		RS_INFO("HCI Version 0x%02x", rtb_cfg.hci_ver);
+		RS_INFO("HCI Revision 0x%04x", rtb_cfg.hci_rev);
+		RS_INFO("LMP Subversion 0x%04x", rtb_cfg.lmp_subver);
+		break;
+
+	case HCI_VENDOR_READ_ROM_VER:
+		rtb_cfg.eversion = skb->data[1];
+		RS_INFO("Read ROM version %02x", rtb_cfg.eversion);
+		break;
+
+	case HCI_VENDOR_READ_CHIP_TYPE:
+		rtb_cfg.chip_type = (skb->data[1] & 0x0f);
+		RS_INFO("Read chip type %02x", rtb_cfg.chip_type);
+		break;
+	default:
+		return;
+	}
+
+	/* Count the cmd num for makeing the seq number aligned */
+	rtb_cfg.num_of_cmd_sent++;
+}
+
+/*
+ * Parse hci command complete event in h5 post state.
+ */
+static void h5_post_hci_cc(struct sk_buff *skb)
+{
+	struct hci_ev_cmd_complete *ev = NULL;
+	uint16_t opcode = 0;
+	uint8_t status = 0;
+
+	skb_pull(skb, HCI_EVENT_HDR_SIZE);
+	ev = (struct hci_ev_cmd_complete *)skb->data;
+	opcode = le16_to_cpu(ev->opcode);
+
+	RS_DBG("Receive cmd complete event of command: %04x", opcode);
+
+	skb_pull(skb, sizeof(struct hci_ev_cmd_complete));
+
+	status = skb->data[0];
+	if (status) {
+		RS_ERR("status is %u for cmd %04x", status, opcode);
+		return;
+	}
+
+	if (rtb_cfg.cmd_state.opcode != opcode) {
+		RS_ERR("%s: Received unexpected cc for cmd %04x, %04x of cc",
+		       __func__, rtb_cfg.cmd_state.opcode, opcode);
+		return;
+	}
+
+	rtb_cfg.cmd_state.state = CMD_STATE_SUCCESS;
+
+	switch (opcode) {
+	case HCI_CMD_RESET:
+		RS_INFO("Received cc of hci reset cmd");
+		rtb_cfg.link_estab_state = H5_ACTIVE;
+		break;
+	default:
+		break;
+	}
+}
+
+/*
+ * Process a hci frame
+ */
+static void hci_recv_frame(struct sk_buff *skb)
+{
+	if (rtb_cfg.link_estab_state == H5_INIT) {
+		if (skb->data[0] == 0x0e)
+			h5_init_hci_cc(skb);
+
+		/*
+		 * rtb_send_ack(rtb_cfg.serial_fd);
+		 * usleep(10000);
+		 * rtb_send_ack(rtb_cfg.serial_fd);
+		 */
+	} else if (rtb_cfg.link_estab_state == H5_PATCH) {
+		if (skb->data[0] != 0x0e) {
+			RS_INFO("Received event 0x%x during download patch",
+				skb->data[0]);
+			return;
+		}
+
+		rtb_cfg.rx_index = skb->data[6];
+
+		/* RS_INFO("rx_index %d", rtb_cfg.rx_index); */
+
+		/* Download fw/config done */
+		if (rtb_cfg.rx_index & 0x80) {
+			rtb_cfg.rx_index &= ~0x80;
+			rtb_cfg.link_estab_state = H5_HCI_RESET;
+		}
+	} else if (rtb_cfg.link_estab_state == H5_HCI_RESET) {
+		if (skb->data[0] == 0x0e)
+			h5_post_hci_cc(skb);
+	} else {
+		RS_ERR("receive packets in active state");
+	}
+}
+
+static void h5_handle_internal_rx(struct sk_buff *skb)
+{
+	int len;
+	uint8_t sync_req[2] = { 0x01, 0x7E };
+	uint8_t sync_resp[2] = { 0x02, 0x7D };
+	uint8_t sync_resp_pkt[0x8] = {
+		0xc0, 0x00, 0x2F, 0x00, 0xD0, 0x02, 0x7D, 0xc0
+	};
+	uint8_t conf_req[2] = { 0x03, 0xFC };
+	uint8_t conf_resp[2] = { 0x04, 0x7B };
+	uint8_t conf_resp_pkt[0x8] = {
+		0xc0, 0x00, 0x2F, 0x00, 0xD0, 0x04, 0x7B, 0xc0
+	};
+
+	if (rtb_cfg.link_estab_state == H5_SYNC) {
+		if (!memcmp(skb->data, sync_req, 2)) {
+			RS_INFO("[SYNC] Get SYNC Pkt\n");
+			len = write(rtb_cfg.serial_fd, sync_resp_pkt, 0x8);
+			if (len != 0x08)
+				RS_ERR("Send h5 sync resp error, %s",
+				       strerror(errno));
+		} else if (!memcmp(skb->data, sync_resp, 2)) {
+			RS_INFO("[SYNC] Get SYNC Resp Pkt");
+			rtb_cfg.link_estab_state = H5_CONFIG;
+		}
+	} else if (rtb_cfg.link_estab_state == H5_CONFIG) {
+		if (!memcmp(skb->data, sync_req, 0x2)) {
+			RS_INFO("[CONFIG] Get SYNC pkt");
+			len = write(rtb_cfg.serial_fd, sync_resp_pkt, 0x8);
+			if (len != 0x08)
+				RS_ERR("Send h5 sync resp error, %s",
+				       strerror(errno));
+		} else if (!memcmp(skb->data, conf_req, 0x2)) {
+			RS_INFO("[CONFIG] Get CONFG pkt");
+			len = write(rtb_cfg.serial_fd, conf_resp_pkt, 0x8);
+			if (len != 0x08)
+				RS_ERR("Send h5 sync resp to ctl error, %s",
+				       strerror(errno));
+		} else if (!memcmp(skb->data, conf_resp, 0x2)) {
+			RS_INFO("[CONFIG] Get CONFG resp pkt");
+			/* Change state to H5_INIT after receiving a conf resp
+			 */
+			rtb_cfg.link_estab_state = H5_INIT;
+			if (skb->data_len > 2) {
+				rtb_cfg.use_crc = ((skb->data[2]) >> 4) & 0x01;
+				RS_INFO("dic is %u, cfg field 0x%02x",
+					rtb_cfg.use_crc, skb->data[2]);
+			}
+		} else {
+			RS_WARN("[CONFIG] Get unknown pkt");
+			rtb_send_ack(rtb_cfg.serial_fd);
+		}
+	}
+}
+
+/*
+ * Process the received complete h5 packet
+ */
+static void h5_complete_rx_pkt(struct rtb_struct *h5)
+{
+	int pass_up = 1;
+	uint8_t *h5_hdr = NULL;
+
+	h5_hdr = (uint8_t *) (h5->rx_skb->data);
+	if (H5_HDR_RELIABLE(h5_hdr)) {
+		/* RS_DBG("Received reliable seqno %u from card", h5->rxseq_txack);
+		 */
+		h5->rxseq_txack = H5_HDR_SEQ(h5_hdr) + 1;
+		/* h5->rxseq_txack %= 8; */
+		h5->rxseq_txack &= 0x07;
+		h5->is_txack_req = 1;
+	}
+
+	h5->rxack = H5_HDR_ACK(h5_hdr);
+
+	switch (H5_HDR_PKT_TYPE(h5_hdr)) {
+	case HCI_ACLDATA_PKT:
+	case HCI_EVENT_PKT:
+	case HCI_COMMAND_PKT:
+		/* h5_remove_acked_pkt(h5); */
+		pass_up = 1;
+		break;
+	case HCI_SCODATA_PKT:
+		pass_up = 1;
+		break;
+	case H5_LINK_CTL_PKT:
+		pass_up = 0;
+		skb_pull(h5->rx_skb, H5_HDR_SIZE);
+		h5_handle_internal_rx(h5->rx_skb);
+		break;
+	default: /* Pure ack or other unexpected pkt */
+		pass_up = 0;
+		break;
+	}
+
+	if (pass_up) {
+		skb_pull(h5->rx_skb, H5_HDR_SIZE);
+		hci_recv_frame(h5->rx_skb);
+	}
+
+	if (h5->is_txack_req) {
+		rtb_send_ack(rtb_cfg.serial_fd);
+		h5->is_txack_req = 0;
+	}
+
+	skb_free(h5->rx_skb);
+
+	h5->rx_state = H5_W4_PKT_DELIMITER;
+	h5->rx_skb = NULL;
+}
+
+/*
+ * Parse the receive data in h5 proto.
+ */
+static int h5_recv(struct rtb_struct *h5, void *data, int count)
+{
+	unsigned char *ptr;
+	ptr = (unsigned char *)data;
+
+	while (count) {
+		if (h5->rx_count) {
+			if (*ptr == 0xc0) {
+				RS_ERR("Short h5 packet");
+				skb_free(h5->rx_skb);
+				h5->rx_state = H5_W4_PKT_START;
+				h5->rx_count = 0;
+			} else
+				h5_unslip_one_byte(h5, *ptr);
+
+			ptr++;
+			count--;
+			continue;
+		}
+
+		switch (h5->rx_state) {
+		case H5_W4_HDR:
+			/* Check header checksum */
+			if ((0xff & (uint8_t)~(h5->rx_skb->data[0] + h5->rx_skb->data[1] +
+			     h5->rx_skb->data[2])) != h5->rx_skb->data[3]) {
+				RS_ERR("h5 hdr checksum error");
+				skb_free(h5->rx_skb);
+				h5->rx_state = H5_W4_PKT_DELIMITER;
+				h5->rx_count = 0;
+				continue;
+			}
+
+			/* The received seq number is unexpected */
+			if (h5->rx_skb->data[0] & 0x80 &&
+			    (h5->rx_skb->data[0] & 0x07) != h5->rxseq_txack) {
+				uint8_t rxseq_txack = (h5->rx_skb->data[0] & 0x07);
+				RS_ERR("Out-of-order packet arrived, got(%u)expected(%u)",
+				     h5->rx_skb->data[0] & 0x07,
+				     h5->rxseq_txack);
+				h5->is_txack_req = 1;
+
+				skb_free(h5->rx_skb);
+				h5->rx_state = H5_W4_PKT_DELIMITER;
+				h5->rx_count = 0;
+
+				/* Depend on whether Controller will reset ack
+				 * number or not
+				 */
+				if (rtb_cfg.link_estab_state == H5_PATCH &&
+				    rtb_cfg.tx_index == rtb_cfg.total_num)
+					rtb_cfg.rxseq_txack = rxseq_txack;
+
+				continue;
+			}
+			h5->rx_state = H5_W4_DATA;
+			h5->rx_count =
+			    (h5->rx_skb->data[1] >> 4) +
+			    (h5->rx_skb->data[2] << 4);
+			continue;
+
+		case H5_W4_DATA:
+			/* Packet with crc */
+			if (h5->rx_skb->data[0] & 0x40) {
+				h5->rx_state = H5_W4_CRC;
+				h5->rx_count = 2;
+			} else {
+				h5_complete_rx_pkt(h5);
+			}
+			continue;
+
+		case H5_W4_CRC:
+			if (bit_rev16(h5->message_crc) != h5_get_crc(h5)) {
+				RS_ERR("Checksum failed, computed %04x received %04x",
+				       bit_rev16(h5->message_crc),
+				       h5_get_crc(h5));
+				skb_free(h5->rx_skb);
+				h5->rx_state = H5_W4_PKT_DELIMITER;
+				h5->rx_count = 0;
+				continue;
+			}
+			skb_trim(h5->rx_skb, h5->rx_skb->data_len - 2);
+			h5_complete_rx_pkt(h5);
+			continue;
+
+		case H5_W4_PKT_DELIMITER:
+			switch (*ptr) {
+			case 0xc0:
+				h5->rx_state = H5_W4_PKT_START;
+				break;
+
+			default:
+				break;
+			}
+			ptr++;
+			count--;
+			break;
+
+		case H5_W4_PKT_START:
+			switch (*ptr) {
+			case 0xc0:
+				ptr++;
+				count--;
+				break;
+
+			default:
+				h5->rx_state = H5_W4_HDR;
+				h5->rx_count = 4;
+				h5->rx_esc_state = H5_ESCSTATE_NOESC;
+				H5_CRC_INIT(h5->message_crc);
+
+				/* Do not increment ptr or decrement count
+				 * Allocate packet. Max len of a H5 pkt=
+				 * 0xFFF (payload) +4 (header) +2 (crc)
+				 */
+				h5->rx_skb = skb_alloc(0x1005);
+				if (!h5->rx_skb) {
+					RS_ERR("Can't alloc skb for new pkt");
+					h5->rx_state = H5_W4_PKT_DELIMITER;
+					h5->rx_count = 0;
+					return 0;
+				}
+				break;
+			}
+			break;
+
+		default:
+			break;
+		}
+	}
+	return count;
+}
+
+static const char *op_string(uint32_t op)
+{
+	switch (op) {
+	case OP_SET_BAUD:
+		return "OP_SET_BAUD";
+	case OP_H5_SYNC:
+		return "OP_H5_SYNC";
+	case OP_H5_CONFIG:
+		return "OP_H5_CONFIG";
+	case OP_HCI_RESET:
+		return "OP_HCI_RESET";
+	case OP_CHIP_TYPE:
+		return "OP_CHIP_TYPE";
+	case OP_ROM_VER:
+		return "OP_ROM_VER";
+	case OP_LMP_VER:
+		return "OP_LMP_VER";
+	default:
+		return "OP_UNKNOWN";
+	}
+}
+
+static int start_transmit_wait(int fd, struct sk_buff *skb,
+			       uint32_t op, unsigned int msec, int retry)
+{
+	unsigned char buf[128];
+	ssize_t result;
+	struct iovec iov;
+	ssize_t ret;
+	uint8_t *data;
+	int len;
+	int op_result = -1;
+	uint64_t expired;
+	int n;
+	struct epoll_event events[MAX_EVENTS];
+	int nfds;
+	uint16_t opcode = 0;
+
+	if (fd == -1 || !skb) {
+		RS_ERR("Invalid parameter");
+		return -1;
+	}
+
+	data = skb->data;
+	len = skb->data_len;
+
+	if (op & (1 << 24)) {
+		opcode = (op & 0xffff);
+		if (opcode != rtb_cfg.cmd_state.opcode ||
+		    rtb_cfg.cmd_state.state != CMD_STATE_UNKNOWN) {
+			RS_ERR("Invalid opcode or cmd state");
+			return -1;
+		}
+	}
+
+	iov.iov_base = data;
+	iov.iov_len = len;
+	do {
+		ret = writev(fd, &iov, 1);
+		if (ret != len)
+			RS_WARN("Writev partially, ret %d", (int)ret);
+	} while (ret < 0 && errno == EINTR);
+
+	if (ret < 0) {
+		RS_ERR("Call writev error, %s", strerror(errno));
+		return -errno;
+	}
+
+	/* Set timeout */
+	if (rtb_cfg.timerfd > 0)
+		timeout_set(rtb_cfg.timerfd, msec);
+
+	do {
+		nfds = epoll_wait(rtb_cfg.epollfd, events, MAX_EVENTS, msec);
+		if (nfds == -1) {
+			RS_ERR("epoll_wait, %s (%d)", strerror(errno), errno);
+			exit(EXIT_FAILURE);
+		}
+
+		for (n = 0; n < nfds; ++n) {
+			if (events[n].data.fd == rtb_cfg.serial_fd) {
+				if (events[n].events & (EPOLLERR | EPOLLHUP |
+				    EPOLLRDHUP)) {
+					RS_ERR("%s: Error happens on serial fd",
+					       __func__);
+					exit(EXIT_FAILURE);
+				}
+				result = read(events[n].data.fd, buf,
+					      sizeof(buf));
+				if (result <= 0) {
+					RS_ERR("Read serial error, %s",
+					       strerror(errno));
+					continue;
+				} else {
+					h5_recv(&rtb_cfg, buf, result);
+				}
+			} else if (events[n].data.fd == rtb_cfg.timerfd) {
+				if (events[n].events & (EPOLLERR | EPOLLHUP |
+				    EPOLLRDHUP)) {
+					RS_ERR("%s: Error happens on timer fd",
+					       __func__);
+					exit(EXIT_FAILURE);
+				}
+				RS_WARN("%s Transmission timeout",
+					op_string(op));
+				result = read(events[n].data.fd, &expired,
+					      sizeof(expired));
+				if (result != sizeof(expired)) {
+					RS_ERR("Skip retransmit");
+					break;
+				}
+				if (retry <= 0) {
+					RS_ERR("Retransmission exhausts");
+					tcflush(fd, TCIOFLUSH);
+					exit(EXIT_FAILURE);
+				}
+
+				iov.iov_base = data;
+				iov.iov_len = len;
+
+				do {
+					ret = writev(fd, &iov, 1);
+					if (ret != len)
+						RS_WARN("Writev partial, %d",
+							(int)ret);
+				} while (ret < 0 && errno == EINTR);
+
+				if (ret < 0) {
+					RS_ERR("ReCall writev error, %s",
+					       strerror(errno));
+					return -errno;
+				}
+
+				retry--;
+				timeout_set(rtb_cfg.timerfd, msec);
+			}
+		}
+
+		if (!(op & (1 << 24))) {
+			/* h5 sync or config */
+			if (op == OP_H5_SYNC && rtb_cfg.link_estab_state ==
+			    H5_CONFIG) {
+				op_result = 0;
+				break;
+			}
+
+			if (op == OP_H5_CONFIG && rtb_cfg.link_estab_state ==
+			    H5_INIT) {
+				op_result = 0;
+				break;
+			}
+			continue;
+		}
+
+		if (rtb_cfg.cmd_state.opcode == opcode &&
+		    rtb_cfg.cmd_state.state == CMD_STATE_SUCCESS) {
+			op_result = 0;
+			break;
+		}
+	} while (1);
+
+	/* Disarms timer */
+	timeout_set(rtb_cfg.timerfd, 0);
+
+	return op_result;
+}
+
+static int h5_download_patch(int dd, int index, uint8_t *data, int len,
+			      struct termios *ti)
+{
+	unsigned char buf[64];
+	int retlen;
+	struct iovec iov;
+	ssize_t ret;
+	int nfds;
+	struct epoll_event events[MAX_EVENTS];
+	int n;
+	int timeout;
+	uint64_t expired;
+	int retry = 3;
+	struct sk_buff *nskb;
+	uint8_t hci_patch[PATCH_DATA_FIELD_MAX_SIZE + 4];
+
+	if (index & 0x80) {
+		rtb_cfg.tx_index = index & 0x7f;
+		timeout = 1000;
+	} else {
+		rtb_cfg.tx_index = index;
+		timeout = 800;
+	}
+
+	/* download cmd: 0xfc20 */
+	hci_patch[0] = 0x20;
+	hci_patch[1] = 0xfc;
+	hci_patch[2] = len + 1;
+	hci_patch[3] = (uint8_t)index;
+	if (data)
+		memcpy(&hci_patch[4], data, len);
+
+	/* length: 2-byte opcode + 1-byte len + 1-byte index + payload */
+	nskb = h5_prepare_pkt(&rtb_cfg, hci_patch, len + 4, HCI_COMMAND_PKT);
+	if (!nskb) {
+		RS_ERR("Prepare command packet for download");
+		return -1;
+	}
+
+	/* Save pkt address and length for re-transmission */
+	len = nskb->data_len;
+	data = nskb->data;
+
+	iov.iov_base = nskb->data;
+	iov.iov_len = nskb->data_len;
+	do {
+		ret = writev(dd, &iov, 1);
+		if (ret != len)
+			RS_WARN("Writev partially, ret %d", (int)ret);
+	} while (ret < 0 && errno == EINTR);
+
+	if (ret < 0) {
+		RS_ERR("Call writev error, %s", strerror(errno));
+		skb_free(nskb);
+		return -errno;
+	}
+
+	/* RS_INFO("%s: tx_index %d, rx_index %d", __func__,
+	 * 	rtb_cfg.tx_index, rtb_cfg.rx_index);
+	 */
+
+	if (index & 0x80) {
+		/* For the last pkt, wait for its complete */
+		tcdrain(dd);
+
+		if (rtb_cfg.uart_flow_ctrl) {
+			RS_INFO("Enable host hw flow control");
+			ti->c_cflag |= CRTSCTS;
+		} else {
+			RS_INFO("Disable host hw flow control");
+			ti->c_cflag &= ~CRTSCTS;
+		}
+
+		if (tcsetattr(dd, TCSANOW, ti) < 0) {
+			RS_ERR("Can't set port settings");
+			skb_free(nskb);
+			return -1;
+		}
+
+		/* RS_INFO("Change baud to %d", rtb_cfg.final_speed);
+		 * if (set_speed(dd, ti, rtb_cfg.final_speed) < 0) {
+		 * 	RS_ERR("Set final speed %d error",
+		 * 	       rtb_cfg.final_speed);
+		 * }
+		 */
+	}
+
+	if (rtb_cfg.timerfd > 0)
+		timeout_set(rtb_cfg.timerfd, timeout);
+
+	do {
+		nfds = epoll_wait(rtb_cfg.epollfd, events, MAX_EVENTS, -1);
+		if (nfds == -1) {
+			RS_ERR("epoll_wait, %s (%d)", strerror(errno), errno);
+			exit(EXIT_FAILURE);
+		}
+
+		for (n = 0; n < nfds; ++n) {
+			if (events[n].data.fd == dd) {
+				if (events[n].events & (EPOLLERR | EPOLLHUP |
+				    EPOLLRDHUP)) {
+					RS_ERR("%s: Error happens on serial fd",
+					       __func__);
+					exit(EXIT_FAILURE);
+				}
+				retlen = read(dd, buf, sizeof(buf));
+				if (retlen <= 0) {
+					RS_ERR("Read serial error, %s", strerror(errno));
+					continue;
+				} else {
+					h5_recv(&rtb_cfg, buf, retlen);
+				}
+			} else if (events[n].data.fd == rtb_cfg.timerfd) {
+				int fd = events[n].data.fd;
+
+				if (events[n].events & (EPOLLERR | EPOLLHUP |
+				    EPOLLRDHUP)) {
+					RS_ERR("%s: Error happens on timer fd",
+					       __func__);
+					exit(EXIT_FAILURE);
+				}
+				RS_WARN("Patch pkt trans timeout, re-trans");
+				ret = read(fd, &expired, sizeof(expired));
+				if (ret != sizeof(expired)) {
+					RS_ERR("Read expired info error");
+					exit(EXIT_FAILURE);
+				}
+				if (retry <= 0) {
+					RS_ERR("%s: Retransmission exhausts",
+					       __func__);
+					tcflush(fd, TCIOFLUSH);
+					exit(EXIT_FAILURE);
+				}
+
+				iov.iov_base = data;
+				iov.iov_len = len;
+
+				do {
+					ret = writev(dd, &iov, 1);
+					if (ret != len)
+						RS_WARN("Writev partial, %d",
+							(int)ret);
+				} while (ret < 0 && errno == EINTR);
+
+				if (ret < 0) {
+					RS_ERR("ReCall writev error, %s",
+					       strerror(errno));
+					skb_free(nskb);
+					return -errno;
+				}
+
+				retry--;
+				timeout_set(fd, timeout);
+			}
+		}
+	} while (rtb_cfg.rx_index != rtb_cfg.tx_index);
+
+	/* Disarms timer */
+	if (rtb_cfg.timerfd > 0)
+		timeout_set(rtb_cfg.timerfd, 0);
+
+	skb_free(nskb);
+	return 0;
+}
+
+/*
+ * Change the Controller's UART speed.
+ */
+int h5_vendor_change_speed(int fd, uint32_t baudrate)
+{
+	struct sk_buff *nskb = NULL;
+	unsigned char cmd[16] = { 0 };
+	int result;
+
+	cmd[0] = 0x17;
+	cmd[1] = 0xfc;
+	cmd[2] = 4;
+
+	baudrate = cpu_to_le32(baudrate);
+#ifdef BAUDRATE_4BYTES
+	memcpy((uint16_t *) & cmd[3], &baudrate, 4);
+#else
+	memcpy((uint16_t *) & cmd[3], &baudrate, 2);
+
+	cmd[5] = 0;
+	cmd[6] = 0;
+#endif
+
+	RS_DBG("baudrate in change speed command: 0x%02x 0x%02x 0x%02x 0x%02x",
+	       cmd[3], cmd[4], cmd[5], cmd[6]);
+
+	nskb = h5_prepare_pkt(&rtb_cfg, cmd, 7, HCI_COMMAND_PKT);
+	if (!nskb) {
+		RS_ERR("Prepare command packet for change speed fail");
+		return -1;
+	}
+
+	rtb_cfg.cmd_state.opcode = HCI_VENDOR_CHANGE_BAUD;;
+	rtb_cfg.cmd_state.state = CMD_STATE_UNKNOWN;
+	result = start_transmit_wait(fd, nskb, OP_SET_BAUD, 1000, 0);
+	skb_free(nskb);
+	if (result < 0) {
+		RS_ERR("OP_SET_BAUD Transmission error");
+		return result;
+	}
+
+	return 0;
+}
+
+/*
+ * Init realtek Bluetooth h5 proto.
+ * There are two steps: h5 sync and h5 config.
+ */
+int rtb_init_h5(int fd, struct termios *ti)
+{
+	struct sk_buff *nskb;
+	unsigned char h5sync[2] = { 0x01, 0x7E };
+	/* 16-bit CCITT CRC may be used and the sliding win size is 4 */
+	unsigned char h5conf[3] = { 0x03, 0xFC, 0x14 };
+	int result;
+
+	/* Disable CRTSCTS by default */
+	ti->c_cflag &= ~CRTSCTS;
+
+	/* set even parity */
+	ti->c_cflag |= PARENB;
+	ti->c_cflag &= ~(PARODD);
+	if (tcsetattr(fd, TCSANOW, ti) < 0) {
+		RS_ERR("Can't set port settings");
+		return -1;
+	}
+
+	/* h5 sync */
+	rtb_cfg.link_estab_state = H5_SYNC;
+	nskb = h5_prepare_pkt(&rtb_cfg, h5sync, sizeof(h5sync),
+			      H5_LINK_CTL_PKT);
+	result = start_transmit_wait(fd, nskb, OP_H5_SYNC, 500, 10);
+	skb_free(nskb);
+	if (result < 0) {
+		RS_ERR("OP_H5_SYNC Transmission error");
+		return -1;
+	}
+
+	/* h5 config */
+	nskb = h5_prepare_pkt(&rtb_cfg, h5conf, sizeof(h5conf), H5_LINK_CTL_PKT);
+	result = start_transmit_wait(fd, nskb, OP_H5_CONFIG, 500, 10);
+	skb_free(nskb);
+	if (result < 0) {
+		RS_ERR("OP_H5_CONFIG Transmission error");
+		return -1;
+	}
+
+	rtb_send_ack(fd);
+	RS_DBG("H5 init finished\n");
+
+	rtb_cfg.cmd_state.state = CMD_STATE_UNKNOWN;
+
+	return 0;
+}
+
+static int h5_hci_reset(int fd)
+{
+	uint8_t cmd[3] = { 0x03, 0x0c, 0x00};
+	struct sk_buff *nskb;
+	int result;
+
+	RS_INFO("%s: Issue hci reset cmd", __func__);
+
+	nskb = h5_prepare_pkt(&rtb_cfg, cmd, sizeof(cmd), HCI_COMMAND_PKT);
+	if (!nskb) {
+		RS_ERR("%s: Failed to alloc mem for hci reset skb", __func__);
+		return -1;
+	}
+
+	rtb_cfg.cmd_state.opcode = HCI_CMD_RESET;
+	rtb_cfg.cmd_state.state = CMD_STATE_UNKNOWN;
+
+	result = start_transmit_wait(fd, nskb, OP_HCI_RESET, 1500, 1);
+	skb_free(nskb);
+	if (result < 0)
+		RS_ERR("hci reset failed");
+
+	return result;
+}
+
+#ifdef SERIAL_NONBLOCK_READ
+static int set_fd_nonblock(int fd)
+{
+	long arg;
+	int old_fl;
+
+	arg = fcntl(fd, F_GETFL);
+	if (arg < 0)
+		return -errno;
+
+	/* Return if already nonblock */
+	if (arg & O_NONBLOCK)
+		return FD_NONBLOCK;
+	old_fl = FD_BLOCK;
+
+	arg |= O_NONBLOCK;
+	if (fcntl(fd, F_SETFL, arg) < 0)
+		return -errno;
+
+	return old_fl;
+}
+
+static int set_fd_block(int fd)
+{
+	long arg;
+
+	arg = fcntl(fd, F_GETFL);
+	if (arg < 0)
+		return -errno;
+
+	/* Return if already block */
+	if (!(arg & O_NONBLOCK))
+		return 0;
+
+	arg &= ~O_NONBLOCK;
+	if (fcntl(fd, F_SETFL, arg) < 0)
+		return -errno;
+
+	return 0;
+}
+#endif
+
+/*
+ * Download Realtek Firmware and Config
+ */
+static int rtb_download_fwc(int fd, uint8_t *buf, int size, int proto,
+			    struct termios *ti)
+{
+	uint8_t curr_idx = 0;
+	uint8_t curr_len = 0;
+	uint8_t lp_len = 0;
+	uint8_t add_pkts = 0;
+	uint16_t end_idx = 0;
+	uint16_t total_idx = 0;
+	uint16_t num;
+	unsigned char *pkt_buf;
+	uint16_t i, j;
+	int result;
+#ifdef SERIAL_NONBLOCK_READ
+	int old_fl;
+#endif
+
+	end_idx = (uint16_t)((size - 1) / PATCH_DATA_FIELD_MAX_SIZE);
+	lp_len = size % PATCH_DATA_FIELD_MAX_SIZE;
+
+	num = rtb_cfg.num_of_cmd_sent;
+	num += end_idx + 1;
+
+	add_pkts = num % 8 ? (8 - num % 8) : 0;
+
+#ifdef SERIAL_NONBLOCK_READ
+	old_fl = set_fd_nonblock(fd);
+	if (old_fl < 0) {
+		RS_ERR("Set fd nonblock error, %s", strerror(errno));
+	}
+	if (old_fl == FD_BLOCK)
+		RS_INFO("old fd state is block");
+#endif
+
+	/* Make sure the next seqno is zero after download patch and
+	 * hci reset
+	 */
+	if (proto == HCI_UART_3WIRE) {
+		if (add_pkts)
+			add_pkts -= 1;
+		else
+			add_pkts += 7;
+	} else
+		add_pkts = 0; /* No additional packets need */
+
+	total_idx = add_pkts + end_idx;
+	rtb_cfg.total_num = total_idx;
+
+	RS_INFO("end_idx: %u, lp_len: %u, additional pkts: %u\n", end_idx,
+		lp_len, add_pkts);
+	RS_INFO("Start downloading...");
+
+	if (lp_len == 0)
+		lp_len = PATCH_DATA_FIELD_MAX_SIZE;
+
+	pkt_buf = buf;
+
+	for (i = 0; i <= total_idx; i++) {
+		/* Index will roll over when it reaches 0x80
+		 * 0, 1, 2, 3, ..., 126, 127(7f), 1, 2, 3, ...
+		 */
+		if (i > 0x7f)
+			j = (i & 0x7f) + 1;
+		else
+			j = i;
+
+		if (i < end_idx) {
+			curr_idx = j;
+			curr_len = PATCH_DATA_FIELD_MAX_SIZE;
+		} else if (i == end_idx) {
+			/* Send last data packets */
+			if (i == total_idx)
+				curr_idx = j | 0x80;
+			else
+				curr_idx = j;
+			curr_len = lp_len;
+		} else if (i < total_idx) {
+			/* Send additional packets */
+			curr_idx = j;
+			pkt_buf = NULL;
+			curr_len = 0;
+			RS_INFO("Send additional packet %u", curr_idx);
+		} else {
+			/* Send last packet */
+			curr_idx = j | 0x80;
+			pkt_buf = NULL;
+			curr_len = 0;
+			RS_INFO("Last packet %u", curr_idx);
+		}
+
+		if (curr_idx & 0x80)
+			RS_INFO("Send last pkt");
+
+		if (proto == HCI_UART_H4) {
+			curr_idx = h4_download_patch(fd, curr_idx, pkt_buf,
+						     curr_len);
+			if (curr_idx != j && i != total_idx) {
+				RS_ERR("Index mismatch %u, curr_idx %u", j,
+				       curr_idx);
+				return -1;
+			}
+		} else if (proto == HCI_UART_3WIRE) {
+			if (h5_download_patch(fd, curr_idx, pkt_buf, curr_len,
+					      ti) < 0)
+				return -1;
+		}
+
+		if (curr_idx < end_idx) {
+			pkt_buf += PATCH_DATA_FIELD_MAX_SIZE;
+		}
+	}
+
+	/* Make hci reset after Controller applies the Firmware and Config */
+	if (proto == HCI_UART_H4)
+		result = h4_hci_reset(fd);
+	else
+		result = h5_hci_reset(fd);
+
+	if (proto == HCI_UART_3WIRE) {
+		/* Make sure the last pure ack is sent */
+		tcdrain(fd);
+	}
+
+	if (result)
+		return result;
+
+
+#ifdef SERIAL_NONBLOCK_READ
+	if (old_fl == FD_BLOCK)
+		set_fd_block(fd);
+#endif
+
+	return 0;
+}
+
+#define ARRAY_SIZE(a)	(sizeof(a)/sizeof(a[0]) )
+struct rtb_baud {
+	uint32_t rtb_speed;
+	int uart_speed;
+};
+
+#ifdef BAUDRATE_4BYTES
+struct rtb_baud baudrates[] = {
+#ifdef RTL_8703A_SUPPORT
+	{0x00004003, 1500000}, /* for rtl8703as */
+#endif
+	{0x0252C014, 115200},
+	{0x0252C00A, 230400},
+	{0x05F75004, 921600},
+	{0x00005004, 1000000},
+	{0x04928002, 1500000},
+	{0x01128002, 1500000},	//8761AT
+	{0x00005002, 2000000},
+	{0x0000B001, 2500000},
+	{0x04928001, 3000000},
+	{0x052A6001, 3500000},
+	{0x00005001, 4000000},
+};
+#else
+struct rtb_baud baudrates[] = {
+	{0x701d, 115200}
+	{0x6004, 921600},
+	{0x4003, 1500000},
+	{0x5002, 2000000},
+	{0x8001, 3000000},
+	{0x9001, 3000000},
+	{0x7001, 3500000},
+	{0x5001, 4000000},
+};
+#endif
+
+static void vendor_speed_to_std(uint32_t rtb_speed, uint32_t *uart_speed)
+{
+	*uart_speed = 115200;
+
+	unsigned int i;
+	for (i = 0; i < ARRAY_SIZE(baudrates); i++) {
+		if (baudrates[i].rtb_speed == rtb_speed) {
+			*uart_speed = baudrates[i].uart_speed;
+			return;
+		}
+	}
+	return;
+}
+
+static inline void std_speed_to_vendor(int uart_speed, uint32_t *rtb_speed)
+{
+	*rtb_speed = 0x701D;
+
+	unsigned int i;
+	for (i = 0; i < ARRAY_SIZE(baudrates); i++) {
+		if (baudrates[i].uart_speed == uart_speed) {
+			*rtb_speed = baudrates[i].rtb_speed;
+			return;
+		}
+	}
+
+	return;
+}
+
+void rtb_read_chip_type(int dd)
+{
+	/* 0xB000A094 */
+	unsigned char cmd_buff[] = {
+		0x61, 0xfc, 0x05, 0x00, 0x94, 0xa0, 0x00, 0xb0
+	};
+	struct sk_buff *nskb;
+	int result;
+
+	nskb = h5_prepare_pkt(&rtb_cfg, cmd_buff, sizeof(cmd_buff),
+			      HCI_COMMAND_PKT);
+	if (!nskb) {
+		RS_ERR("Alloc chip type cmd skb buff error");
+		exit(EXIT_FAILURE);
+	}
+
+	rtb_cfg.cmd_state.opcode = HCI_VENDOR_READ_CHIP_TYPE;
+	rtb_cfg.cmd_state.state = CMD_STATE_UNKNOWN;
+	result = start_transmit_wait(dd, nskb, OP_CHIP_TYPE, 250, 3);
+	skb_free(nskb);
+	if (result < 0)
+		RS_ERR("OP_CHIP_TYPE Transmission error");
+
+	return;
+}
+
+/*
+ * Read ECO version with vendor cmd 0xfc65
+ */
+void rtb_read_eversion(int dd)
+{
+	int result;
+	unsigned char cmd_buf[3] = { 0x6d, 0xfc, 0x00 };
+	struct sk_buff *nskb;
+
+	nskb= h5_prepare_pkt(&rtb_cfg, cmd_buf, 3, HCI_COMMAND_PKT);
+	if (!nskb) {
+		RS_ERR("Alloc eversion cmd skb buff error");
+		exit(EXIT_FAILURE);
+	}
+
+	rtb_cfg.cmd_state.opcode = HCI_VENDOR_READ_ROM_VER;
+	rtb_cfg.cmd_state.state = CMD_STATE_UNKNOWN;
+	result = start_transmit_wait(dd, nskb, OP_ROM_VER, 500, 3);
+	skb_free(nskb);
+	if (result < 0) {
+		RS_ERR("OP_ROM_VER Transmit error");
+	}
+
+	return;
+}
+
+void rtb_read_local_version(int dd)
+{
+	int result;
+	unsigned char cmd_buf[3] = { 0x01, 0x10, 0x00 };
+	struct sk_buff *nskb;
+
+	nskb = h5_prepare_pkt(&rtb_cfg, cmd_buf, 3, HCI_COMMAND_PKT);
+	if (!nskb) {
+		RS_ERR("Alloc local ver cmd skb buff error");
+		exit(EXIT_FAILURE);
+	}
+
+	rtb_cfg.cmd_state.state = CMD_STATE_UNKNOWN;
+	rtb_cfg.cmd_state.opcode = HCI_CMD_READ_LOCAL_VER;
+	result = start_transmit_wait(dd, nskb, OP_LMP_VER, 500, 3);
+	skb_free(nskb);
+	if (result < 0) {
+		RS_ERR("OP_LMP_VER Transmit error");
+	}
+
+	return;
+}
+
+/*
+ * Config Realtek Bluetooth.
+ * Config parameters are got from Realtek Config file and FW.
+ *
+ * speed is the init_speed in uart struct
+ * Returns 0 on success
+ */
+static int rtb_config(int fd, int proto, int speed, struct termios *ti)
+{
+	int final_speed = 0;
+	int ret = 0;
+
+	rtb_cfg.proto = proto;
+
+	/* Read Local Version Information and RTK ROM version */
+	if (proto == HCI_UART_3WIRE) {
+		RS_INFO("Realtek H5 IC");
+		rtb_read_local_version(fd);
+		rtb_read_eversion(fd);
+	} else {
+		RS_INFO("Realtek H4 IC");
+
+		/* The following set is for special requirement that enables
+		 * flow control before initializing */
+#ifdef RTL8723DSH4_UART_HWFLOWC
+		ti->c_cflag &= ~PARENB;
+		ti->c_cflag |= CRTSCTS;
+		if (tcsetattr(fd, TCSANOW, ti) < 0) {
+			RS_ERR("H4 Can't enable RTSCTS");
+			return -1;
+		}
+		usleep(20 * 1000);
+#endif
+		h4_read_local_ver(fd);
+		h4_vendor_read_rom_ver(fd);
+		if (rtb_cfg.lmp_subver == ROM_LMP_8761btc) {
+			/* 8761B Test Chip */
+			rtb_cfg.chip_type = CHIP_8761BTC;
+			rtb_cfg.uart_flow_ctrl = 1;
+			/* TODO: Change to different uart baud */
+			std_speed_to_vendor(1500000, &rtb_cfg.vendor_baud);
+			goto change_baud;
+		} else if (rtb_cfg.lmp_subver == ROM_LMP_8761a) {
+			if (rtb_cfg.hci_rev == 0x000b) {
+				/* 8761B Test Chip without download */
+				rtb_cfg.chip_type = CHIP_8761BH4;
+				/* rtb_cfg.uart_flow_ctrl = 1; */
+				/* TODO: Change to different uart baud */
+				/* std_speed_to_vendor(1500000, &rtb_cfg.vendor_baud);
+				 * goto change_baud;
+				 */
+			} else if (rtb_cfg.hci_rev == 0x000a) {
+				if (rtb_cfg.eversion == 3)
+					rtb_cfg.chip_type = CHIP_8761ATF;
+				else if (rtb_cfg.eversion == 2)
+					rtb_cfg.chip_type = CHIP_8761AT;
+				else
+					rtb_cfg.chip_type = CHIP_UNKNOWN;
+			}
+		} else if (rtb_cfg.lmp_subver == ROM_LMP_8723b) {
+			if (rtb_cfg.hci_ver == 0x08 &&
+			    rtb_cfg.hci_rev == 0x000d) {
+				rtb_cfg.chip_type = CHIP_8723DS;
+			} else if (rtb_cfg.hci_ver == 0x06 &&
+				 rtb_cfg.hci_rev == 0x000b) {
+				rtb_cfg.chip_type = CHIP_8723BS;
+			} else {
+				RS_ERR("H4: unknown chip");
+				return -1;
+			}
+		}
+
+	}
+
+	RS_INFO("LMP Subversion 0x%04x", rtb_cfg.lmp_subver);
+	RS_INFO("EVersion %u", rtb_cfg.eversion);
+
+	switch (rtb_cfg.lmp_subver) {
+	case ROM_LMP_8723a:
+		break;
+	case ROM_LMP_8723b:
+#ifdef RTL_8703A_SUPPORT
+		/* Set chip type for matching fw/config entry */
+		rtl->chip_type = CHIP_8703AS;
+#endif
+		break;
+	case ROM_LMP_8821a:
+		break;
+	case ROM_LMP_8761a:
+		break;
+	case ROM_LMP_8703b:
+		rtb_read_chip_type(fd);
+		break;
+	}
+
+	rtb_cfg.patch_ent = get_patch_entry(&rtb_cfg);
+	if (rtb_cfg.patch_ent) {
+		RS_INFO("IC: %s", rtb_cfg.patch_ent->ic_name);
+		RS_INFO("Firmware/config: %s, %s",
+			rtb_cfg.patch_ent->patch_file,
+			rtb_cfg.patch_ent->config_file);
+	} else {
+		RS_ERR("Can not find firmware/config entry\n");
+		return -1;
+	}
+
+	rtb_cfg.config_buf = rtb_read_config(&rtb_cfg, &rtb_cfg.config_len);
+	if (!rtb_cfg.config_buf) {
+		RS_ERR("Read Config file error, use eFuse settings");
+		rtb_cfg.config_len = 0;
+	}
+
+	rtb_cfg.fw_buf = rtb_read_firmware(&rtb_cfg, &rtb_cfg.fw_len);
+	if (!rtb_cfg.fw_buf) {
+		RS_ERR("Read Bluetooth firmware error");
+		rtb_cfg.fw_len = 0;
+		/* Free config buf */
+		if (rtb_cfg.config_buf) {
+			free(rtb_cfg.config_buf);
+			rtb_cfg.config_buf = NULL;
+			rtb_cfg.config_len = 0;
+		}
+		return -1;
+	} else {
+		rtb_cfg.total_buf = rtb_get_final_patch(fd, proto,
+							&rtb_cfg.total_len);
+		/* If the above function executes successfully, the Config and
+		 * patch were copied to the total buf */
+
+		/* Free config buf */
+		if (rtb_cfg.config_buf) {
+			free(rtb_cfg.config_buf);
+			rtb_cfg.config_buf = NULL;
+		}
+		/* Free the fw buf */
+		free(rtb_cfg.fw_buf);
+		rtb_cfg.fw_buf = NULL;
+		rtb_cfg.fw_len = 0;
+
+		if (!rtb_cfg.total_buf) {
+			RS_ERR("Failed to get the final patch");
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	if (rtb_cfg.total_len > RTB_PATCH_LENGTH_MAX) {
+		RS_ERR("Total length of fwc is larger than allowed");
+		goto buf_free;
+	}
+
+	RS_INFO("Total len %d for fwc", rtb_cfg.total_len);
+
+	/* rtl8723ds h4 */
+	if (rtb_cfg.chip_type == CHIP_8723DS &&
+	    rtb_cfg.proto == HCI_UART_H4) {
+		if (rtb_cfg.parenb) {
+			/* set parity */
+			ti->c_cflag |= PARENB;
+			if (rtb_cfg.pareven)
+				ti->c_cflag &= ~(PARODD);
+			else
+				ti->c_cflag |= PARODD;
+			if (tcsetattr(fd, TCSANOW, ti) < 0) {
+				RS_ERR("8723DSH4 Can't set parity");
+				goto buf_free;
+			}
+		}
+	}
+
+change_baud:
+	/* change baudrate if needed
+	 * rtb_cfg.vendor_baud is a __u32/__u16 vendor-specific variable
+	 * parsed from config file
+	 * */
+	if (rtb_cfg.vendor_baud == 0) {
+		/* No baud setting in Config file */
+		std_speed_to_vendor(speed, &rtb_cfg.vendor_baud);
+		RS_INFO("No baud from Config file, set baudrate: %d, 0x%08x",
+			speed, rtb_cfg.vendor_baud);
+		goto start_download;
+	} else
+		vendor_speed_to_std(rtb_cfg.vendor_baud,
+				    (uint32_t *)&(rtb_cfg.final_speed));
+
+	if (rtb_cfg.final_speed == 115200) {
+		RS_INFO("Final speed is %d, no baud change needs",
+			rtb_cfg.final_speed);
+		goto start_download;
+	}
+
+	if (proto == HCI_UART_3WIRE)
+		h5_vendor_change_speed(fd, rtb_cfg.vendor_baud);
+	else
+		h4_vendor_change_speed(fd, rtb_cfg.vendor_baud);
+
+	/* Make sure the ack for cmd complete event is transmitted */
+	tcdrain(fd);
+	usleep(50000); /* The same value as before */
+	final_speed = rtb_cfg.final_speed ? rtb_cfg.final_speed : speed;
+	RS_INFO("Final speed %d", final_speed);
+	if (set_speed(fd, ti, final_speed) < 0) {
+		RS_ERR("Can't set baud rate: %d, %d, %d", final_speed,
+		       rtb_cfg.final_speed, speed);
+		goto buf_free;
+	}
+
+start_download:
+	/* For 8761B Test chip, no patch to download */
+	if (rtb_cfg.chip_type == CHIP_8761BTC)
+		goto done;
+
+	if (rtb_cfg.total_len > 0 && rtb_cfg.dl_fw_flag) {
+		rtb_cfg.link_estab_state = H5_PATCH;
+		rtb_cfg.rx_index = -1;
+
+		ret = rtb_download_fwc(fd, rtb_cfg.total_buf, rtb_cfg.total_len,
+				       proto, ti);
+		free(rtb_cfg.total_buf);
+		if (ret < 0)
+			return ret;
+	}
+
+done:
+
+	RS_DBG("Init Process finished");
+	return 0;
+
+buf_free:
+	free(rtb_cfg.total_buf);
+	return -1;
+}
+
+int rtb_init(int fd, int proto, int speed, struct termios *ti)
+{
+	struct epoll_event ev;
+	int result;
+
+	RS_INFO("Realtek hciattach version %s \n", RTK_VERSION);
+
+	memset(&rtb_cfg, 0, sizeof(rtb_cfg));
+	rtb_cfg.serial_fd = fd;
+	rtb_cfg.dl_fw_flag = 1;
+
+	rtb_cfg.epollfd = epoll_create(64);
+	if (rtb_cfg.epollfd == -1) {
+		RS_ERR("epoll_create1, %s (%d)", strerror(errno), errno);
+		exit(EXIT_FAILURE);
+	}
+
+	ev.events = EPOLLIN | EPOLLERR | EPOLLHUP | EPOLLRDHUP;
+	ev.data.fd = fd;
+	if (epoll_ctl(rtb_cfg.epollfd, EPOLL_CTL_ADD, fd, &ev) == -1) {
+		RS_ERR("epoll_ctl: epoll ctl add, %s (%d)", strerror(errno),
+		       errno);
+		exit(EXIT_FAILURE);
+	}
+
+	rtb_cfg.timerfd = timerfd_create(CLOCK_MONOTONIC, 0);
+	if (rtb_cfg.timerfd == -1) {
+		RS_ERR("timerfd_create error, %s (%d)", strerror(errno), errno);
+		return -1;
+	}
+
+	if (rtb_cfg.timerfd > 0) {
+		ev.events = EPOLLIN | EPOLLERR | EPOLLHUP | EPOLLRDHUP;
+		ev.data.fd = rtb_cfg.timerfd;
+		if (epoll_ctl(rtb_cfg.epollfd, EPOLL_CTL_ADD,
+			      rtb_cfg.timerfd, &ev) == -1) {
+			RS_ERR("epoll_ctl: epoll ctl add, %s (%d)",
+			       strerror(errno), errno);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	RS_INFO("Use epoll");
+
+	if (proto == HCI_UART_3WIRE) {
+		if (rtb_init_h5(fd, ti) < 0)
+			return -1;;
+	}
+
+	result = rtb_config(fd, proto, speed, ti);
+
+	epoll_ctl(rtb_cfg.epollfd, EPOLL_CTL_DEL, fd, NULL);
+	epoll_ctl(rtb_cfg.epollfd, EPOLL_CTL_DEL, rtb_cfg.timerfd, NULL);
+	close(rtb_cfg.timerfd);
+	rtb_cfg.timerfd = -1;
+
+	return result;
+}
+
+int rtb_post(int fd, int proto, struct termios *ti)
+{
+	/* No need to change baudrate */
+	/* if (rtb_cfg.final_speed)
+	 * 	return set_speed(fd, ti, rtb_cfg.final_speed);
+	 */
+
+	return 0;
+}
diff --git a/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/rtb_fwc.c b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/rtb_fwc.c
new file mode 100644
index 0000000..e869294
--- /dev/null
+++ b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/rtb_fwc.c
@@ -0,0 +1,1244 @@
+/*
+ *  Copyright (C) 2018 Realtek Semiconductor Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <unistd.h>
+#include <ctype.h>
+
+#ifndef PATH_MAX
+#define PATH_MAX	1024
+#endif
+
+#include "hciattach.h"
+#include "rtb_fwc.h"
+
+#define USE_CUSTOMER_ADDRESS
+
+#define FIRMWARE_DIRECTORY  "/lib/firmware/rtlbt/"
+#define BT_CONFIG_DIRECTORY "/lib/firmware/rtlbt/"
+
+#ifdef USE_CUSTOMER_ADDRESS
+#define BT_ADDR_FILE        "/opt/bdaddr"
+static uint8_t customer_bdaddr = 0;
+#endif
+
+struct list_head {
+	struct list_head *next, *prev;
+};
+
+struct cfg_list_item {
+	struct list_head list;
+	uint8_t *cfg_data;
+	uint16_t offset;
+	uint8_t len;
+	uint8_t data[0];
+};
+
+static struct list_head list_configs;
+
+#define EXTRA_CONFIG_FILE	"/opt/rtk_btconfig.txt"
+static struct list_head list_extracfgs;
+
+struct rtb_cfg_item {
+	uint16_t offset;
+	uint8_t len;
+	uint8_t data[0];
+} __attribute__ ((packed));
+
+#define RTB_CFG_HDR_LEN		6
+
+struct rtb_patch_entry {
+	uint16_t chip_id;
+	uint16_t patch_len;
+	uint32_t soffset;
+	uint32_t svn_ver;
+	uint32_t coex_ver;
+} __attribute__ ((packed));
+
+struct rtb_patch_hdr {
+	uint8_t signature[8];
+	uint32_t fw_version;
+	uint16_t number_of_patch;
+	struct rtb_patch_entry entry[0];
+} __attribute__ ((packed));
+
+uint16_t project_id[]=
+{
+	ROM_LMP_8723a,
+	ROM_LMP_8723b, /* RTL8723BS */
+	ROM_LMP_8821a, /* RTL8821AS */
+	ROM_LMP_8761a, /* RTL8761ATV */
+
+	ROM_LMP_8703a,
+	ROM_LMP_8763a,
+	ROM_LMP_8703b,
+	ROM_LMP_8723c, /* index 7 for 8723CS. What is for other 8723CS  */
+	ROM_LMP_8822b, /* RTL8822BS */
+	ROM_LMP_8723b, /* RTL8723DS */
+	ROM_LMP_8821a, /* id 10 for RTL8821CS, lmp subver 0x8821 */
+	ROM_LMP_NONE,
+	ROM_LMP_NONE,
+	ROM_LMP_8822c, /* id 13 for RTL8822CS, lmp subver 0x8822 */
+	ROM_LMP_8761a, /* id 14 for 8761B */
+};
+
+static struct patch_info h4_patch_table[] = {
+	/* match flags, chip type, lmp subver, proj id(unused), hci_ver,
+	 * hci_rev, ...
+	 */
+
+	/* RTL8761AT */
+	{ RTL_FW_MATCH_CHIP_TYPE, CHIP_8761AT,
+		0x8761, 0xffff, 0, 0x000a,
+		"rtl8761at_fw", "rtl8761at_config", "RTL8761AT" },
+	/* RTL8761ATF */
+	{ RTL_FW_MATCH_CHIP_TYPE, CHIP_8761ATF,
+		0x8761, 0xffff, 0, 0x000a,
+		"rtl8761atf_fw", "rtl8761atf_config", "RTL8761ATF" },
+	/* RTL8761B(8763) H4 Test Chip without download
+	 * FW/Config is not used.
+	 */
+	{ RTL_FW_MATCH_CHIP_TYPE, CHIP_8761BTC,
+		0x8763, 0xffff, 0, 0x000b,
+		"rtl8761btc_fw", "rtl8761btc_config", "RTL8761BTC" },
+	/* RTL8761B H4 Test Chip wihtout download*/
+	{ RTL_FW_MATCH_CHIP_TYPE, CHIP_8761BH4,
+		0x8761, 0xffff, 0, 0x000b,
+		"rtl8761bh4_fw", "rtl8761bh4_config", "RTL8761BH4" },
+
+	/* RTL8723DS */
+	{ RTL_FW_MATCH_HCI_VER | RTL_FW_MATCH_HCI_REV, CHIP_8723DS,
+		ROM_LMP_8723b, ROM_LMP_8723b, 8, 0x000d,
+		"rtl8723dsh4_fw", "rtl8723dsh4_config", "RTL8723DSH4"},
+
+	{ 0, 0, 0, ROM_LMP_NONE, 0, 0, "rtl_none_fw", "rtl_none_config", "NONE"}
+};
+
+static struct patch_info patch_table[] = {
+	/* match flags, chip type, lmp subver, proj id(unused), hci_ver,
+	 * hci_rev, ...
+	 */
+
+	/* RTL8723AS */
+	{ 0, 0, ROM_LMP_8723a, ROM_LMP_8723a, 0, 0,
+		"rtl8723a_fw", "rtl8723a_config", "RTL8723AS"},
+	/* RTL8821CS */
+	{ RTL_FW_MATCH_HCI_REV, CHIP_8821CS,
+		ROM_LMP_8821a, ROM_LMP_8821a, 0, 0x000c,
+		"rtl8821c_fw", "rtl8821c_config", "RTL8821CS"},
+	/* RTL8821AS */
+	{ 0, 0, ROM_LMP_8821a, ROM_LMP_8821a, 0, 0,
+		"rtl8821a_fw", "rtl8821a_config", "RTL8821AS"},
+	/* RTL8761ATV */
+	{ RTL_FW_MATCH_HCI_VER | RTL_FW_MATCH_HCI_REV, 0,
+		ROM_LMP_8761a, ROM_LMP_8761a, 0x06, 0x000a,
+		"rtl8761a_fw", "rtl8761a_config", "RTL8761ATV"},
+	/* RTL8761BTV */
+	{ RTL_FW_MATCH_HCI_VER | RTL_FW_MATCH_HCI_REV, CHIP_8761B,
+		ROM_LMP_8761a, ROM_LMP_8761a, 0x0a, 0x000b,
+		"rtl8761b_fw", "rtl8761b_config", "RTL8761BTV"},
+
+	/* RTL8703AS
+	 * RTL8822BS
+	 * */
+#ifdef RTL_8703A_SUPPORT
+	{ RTL_FW_MATCH_CHIP_TYPE, CHIP_8703AS,
+		ROM_LMP_8723b, ROM_LMP_8723b, 0, 0,
+		"rtl8703a_fw", "rtl8703a_config", "RTL8703AS"},
+#endif
+	{ RTL_FW_MATCH_HCI_REV, CHIP_8822BS,
+		ROM_LMP_8822b, ROM_LMP_8822b, 0, 0x000b,
+		"rtl8822b_fw", "rtl8822b_config", "RTL8822BS"},
+	{ RTL_FW_MATCH_HCI_REV, CHIP_8822CS,
+		ROM_LMP_8822c, ROM_LMP_8822c, 0, 0x000c,
+		"rtl8822cs_fw", "rtl8822cs_config", "RTL8822CS"},
+
+	/* RTL8703BS
+	 * RTL8723CS_XX
+	 * RTL8723CS_CG
+	 * RTL8723CS_VF
+	 * Use the sampe lmp subversion 0x8703
+	 * */
+	{ RTL_FW_MATCH_CHIP_TYPE, CHIP_8703BS,
+		ROM_LMP_8703b, ROM_LMP_8703b, 0, 0,
+		"rtl8703b_fw", "rtl8703b_config", "RTL8703BS"},
+	{ RTL_FW_MATCH_CHIP_TYPE, CHIP_8723CS_XX,
+		ROM_LMP_8703b, ROM_LMP_8723cs_xx, 0, 0,
+		"rtl8723cs_fw", "rtl8723cs_config", "RTL8723CS_XX"},
+	{ RTL_FW_MATCH_CHIP_TYPE, CHIP_8723CS_CG,
+		ROM_LMP_8703b, ROM_LMP_8723cs_cg, 0, 0,
+		"rtl8723cs_fw", "rtl8723cs_config", "RTL8723CS_CG"},
+	{ RTL_FW_MATCH_CHIP_TYPE, CHIP_8723CS_VF,
+		ROM_LMP_8703b, ROM_LMP_8723cs_vf, 0, 0,
+		"rtl8723cs_fw", "rtl8723cs_config", "RTL8723CS_VF"},
+
+	/* RTL8723BS */
+	{ RTL_FW_MATCH_HCI_VER | RTL_FW_MATCH_HCI_REV, 0,
+		ROM_LMP_8723b, ROM_LMP_8723b, 6, 0x000b,
+		"rtl8723b_fw", "rtl8723b_config", "RTL8723BS"},
+	/* RTL8723DS */
+	{ RTL_FW_MATCH_HCI_VER | RTL_FW_MATCH_HCI_REV, CHIP_8723DS,
+		ROM_LMP_8723b, ROM_LMP_8723b, 8, 0x000d,
+		"rtl8723d_fw", "rtl8723d_config", "RTL8723DS"},
+	/* add entries here*/
+
+	{ 0, 0, 0, ROM_LMP_NONE, 0, 0, "rtl_none_fw", "rtl_none_config", "NONE"}
+};
+
+static __inline uint16_t get_unaligned_le16(uint8_t * p)
+{
+	return (uint16_t) (*p) + ((uint16_t) (*(p + 1)) << 8);
+}
+
+static __inline uint32_t get_unaligned_le32(uint8_t * p)
+{
+	return (uint32_t) (*p) + ((uint32_t) (*(p + 1)) << 8) +
+	    ((uint32_t) (*(p + 2)) << 16) + ((uint32_t) (*(p + 3)) << 24);
+}
+
+/* list head from kernel */
+#define offsetof(TYPE, MEMBER)	((size_t)&((TYPE *)0)->MEMBER)
+
+#define container_of(ptr, type, member) ({                      \
+	const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
+	(type *)( (char *)__mptr - offsetof(type,member) );})
+
+#define list_entry(ptr, type, member) \
+	container_of(ptr, type, member)
+
+#define list_for_each_safe(pos, n, head) \
+	for (pos = (head)->next, n = pos->next; pos != (head); \
+		pos = n, n = pos->next)
+
+static inline void INIT_LIST_HEAD(struct list_head *list)
+{
+	list->next = list;
+	list->prev = list;
+}
+
+static inline int list_empty(const struct list_head *head)
+{
+	return head->next == head;
+}
+
+static inline void __list_add(struct list_head *_new,
+			      struct list_head *prev,
+			      struct list_head *next)
+{
+	next->prev = _new;
+	_new->next = next;
+	_new->prev = prev;
+	prev->next = _new;
+}
+
+static inline void list_add_tail(struct list_head *_new, struct list_head *head)
+{
+	__list_add(_new, head->prev, head);
+}
+
+static inline void __list_del(struct list_head *prev, struct list_head *next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+#define LIST_POISON1  ((void *) 0x00100100)
+#define LIST_POISON2  ((void *) 0x00200200)
+static inline void list_del(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	entry->next = (struct list_head*)LIST_POISON1;
+	entry->prev = (struct list_head*)LIST_POISON2;
+}
+
+static inline void __list_splice(const struct list_head *list,
+				 struct list_head *prev,
+				 struct list_head *next)
+{
+	struct list_head *first = list->next;
+	struct list_head *last = list->prev;
+
+	first->prev = prev;
+	prev->next = first;
+
+	last->next = next;
+	next->prev = last;
+}
+
+static inline void list_splice_tail(struct list_head *list,
+				struct list_head *head)
+{
+	if (!list_empty(list))
+		__list_splice(list, head->prev, head);
+}
+
+static int config_lists_init(void)
+{
+	INIT_LIST_HEAD(&list_configs);
+	INIT_LIST_HEAD(&list_extracfgs);
+
+	return 0;
+}
+
+static void config_lists_free(void)
+{
+	struct list_head *iter;
+	struct list_head *tmp;
+	struct list_head *head;
+	struct cfg_list_item *n;
+
+	if (!list_empty(&list_extracfgs))
+		list_splice_tail(&list_extracfgs, &list_configs);
+	head = &list_configs;
+	list_for_each_safe(iter, tmp, head) {
+		n = list_entry(iter, struct cfg_list_item, list);
+		if (n) {
+			list_del(&n->list);
+			free(n);
+		}
+	}
+
+	INIT_LIST_HEAD(&list_configs);
+	INIT_LIST_HEAD(&list_extracfgs);
+}
+
+static void line_process(char *buf, int len /*@unused@*/)
+{
+	char *argv[32];
+	int argc = 0;
+	char *ptr = buf;
+	char *head = buf;
+	unsigned long int offset;
+	uint8_t l;
+	uint8_t i = 0;
+	struct cfg_list_item *item;
+
+	RS_INFO("%s", buf);
+
+	while ((ptr = strsep(&head, ", \t")) != NULL) {
+		if (!ptr[0])
+			continue;
+		argv[argc++] = ptr;
+		if (argc >= 32) {
+			RS_WARN("%s: Config item is too long", __func__);
+			break;
+		}
+	}
+
+	if (argc < 4) {
+		RS_WARN("%s: Invalid Config item, ignore", __func__);
+		return;
+	}
+
+	offset = strtoul(argv[0], NULL, 16);
+	offset = offset | (strtoul(argv[1], NULL, 16) << 8);
+	RS_INFO("Extra Config offset %04lx", offset);
+	l = (uint8_t)strtoul(argv[2], NULL, 16);
+	if (l != (uint8_t)(argc - 3)) {
+		RS_ERR("Invalid Config item len %u", l);
+		return;
+	}
+
+	item = malloc(sizeof(*item) + l);
+	if (!item) {
+		RS_WARN("%s: Cannot alloc mem for item, %04lx, %u", __func__,
+			offset, l);
+		return;
+	}
+	memset(item, 0, sizeof(*item));
+	item->cfg_data = item->data;
+	item->offset = (uint16_t)offset;
+	item->len = l;
+	for (i = 0; i < l; i++)
+		item->data[i] = (uint8_t)strtoul(argv[3 + i], NULL, 16);
+	list_add_tail(&item->list, &list_extracfgs);
+}
+
+static void config_process(uint8_t *buf, int len /*@unused@*/)
+{
+	char *head = (void *)buf;
+	char *ptr = (void *)buf;
+
+	while ((ptr = strsep(&head, "\n\r")) != NULL) {
+		if (!ptr[0])
+			continue;
+		line_process(ptr, strlen(ptr) + 1);
+	}
+}
+
+static void parse_extra_config(const char *path)
+{
+	int fd;
+	uint8_t buf[256];
+	int result;
+
+	fd = open(path, O_RDONLY);
+	if (fd == -1) {
+		RS_INFO("Couldnt open extra config %s, %s", path,
+			strerror(errno));
+		return;
+	}
+
+	result = read(fd, buf, sizeof(buf));
+	if (result == -1) {
+		RS_ERR("Couldnt read %s, %s", path, strerror(errno));
+		goto done;
+	} else if (result == 0) {
+		RS_ERR("File is empty");
+		goto done;
+	}
+
+	if (result > 254) {
+		RS_ERR("Extra Config file is too big");
+		goto done;
+	}
+	buf[result++] = '\n';
+	buf[result++] = '\0';
+
+	config_process(buf, result);
+
+done:
+	close(fd);
+}
+
+/* Get the entry from patch_table according to LMP subversion */
+struct patch_info *get_patch_entry(struct rtb_struct *btrtl)
+{
+	struct patch_info *n = NULL;
+
+	if (btrtl->proto == HCI_UART_3WIRE)
+		n = patch_table;
+	else
+		n = h4_patch_table;
+	for (; n->lmp_subver; n++) {
+		if ((n->match_flags & RTL_FW_MATCH_CHIP_TYPE) &&
+		    n->chip_type != btrtl->chip_type)
+			continue;
+		if ((n->match_flags & RTL_FW_MATCH_HCI_VER) &&
+		    n->hci_ver != btrtl->hci_ver)
+			continue;
+		if ((n->match_flags & RTL_FW_MATCH_HCI_REV) &&
+		    n->hci_rev != btrtl->hci_rev)
+			continue;
+		if (n->lmp_subver != btrtl->lmp_subver)
+			continue;
+
+		break;
+	}
+
+	return n;
+}
+
+#ifdef USE_CUSTOMER_ADDRESS
+static int is_mac(uint8_t chip_type, uint16_t offset)
+{
+	int result = 0;
+
+	switch (chip_type) {
+	case CHIP_8822BS:
+	case CHIP_8723DS:
+	case CHIP_8821CS:
+	case CHIP_8723CS_XX:
+	case CHIP_8723CS_CG:
+	case CHIP_8723CS_VF:
+		if (offset == 0x0044)
+			return 1;
+		break;
+	case CHIP_8822CS:
+	case CHIP_8761B:
+		if (offset == 0x0030)
+			return 1;
+		break;
+	case 0: /* special for not setting chip_type */
+	case CHIP_8761AT:
+	case CHIP_8761ATF:
+	case CHIP_8761BTC:
+	case CHIP_8723BS:
+		if (offset == 0x003c)
+			return 1;
+		break;
+	default:
+		break;
+	}
+
+	return result;
+}
+
+static void fill_mac_offset(uint8_t chip_type, uint8_t b[2])
+{
+	switch (chip_type) {
+	case CHIP_8822BS:
+	case CHIP_8723DS:
+	case CHIP_8821CS:
+		b[0] = 0x44;
+		b[1] = 0x00;
+		break;
+	case CHIP_8822CS:
+	case CHIP_8761B:
+		b[0] = 0x30;
+		b[1] = 0x00;
+		break;
+	case 0: /* special for not setting chip_type */
+	case CHIP_8761AT:
+	case CHIP_8761ATF:
+	case CHIP_8761BTC:
+	case CHIP_8723BS:
+		b[0] = 0x3c;
+		b[1] = 0x00;
+		break;
+	}
+}
+#endif
+
+static void merge_configs(uint8_t *cfg_buf, size_t *plen)
+{
+	struct list_head *iter, *tmp;
+	struct cfg_list_item *item;
+	uint8_t *buf;
+	uint16_t tmp_len;
+
+	list_for_each_safe(iter, tmp, &list_extracfgs) {
+		struct list_head *iter2, *tmp2;
+
+		item = list_entry(iter, struct cfg_list_item, list);
+		list_for_each_safe(iter2, tmp2, &list_configs) {
+			struct cfg_list_item *n;
+
+			n = list_entry(iter2, struct cfg_list_item, list);
+			if (item->offset == n->offset) {
+				if (item->len == n->len) {
+					RS_INFO("Update cfg: %04x, %u",
+						n->offset, n->len);
+					memcpy(n->data, item->data, n->len);
+					if (n->cfg_data)
+						memcpy(n->cfg_data, item->data,
+						       n->len);
+					list_del(&item->list);
+					free(item);
+					break;
+				}
+
+				RS_WARN("item mismatch %04x %u %u",
+					item->offset, item->len,
+					n->len);
+				list_del(&item->list);
+				free(item);
+			}
+		}
+	}
+
+	buf = cfg_buf + *plen;
+	list_for_each_safe(iter, tmp, &list_extracfgs) {
+		item = list_entry(iter, struct cfg_list_item, list);
+		buf[0] = item->offset & 0xff;
+		buf[1] = (item->offset >> 8) & 0xff;
+		buf[2] = item->len;
+		memcpy(buf + 3, item->data, item->len);
+		buf += (3 + item->len);
+		*plen += (3 + item->len);
+		list_del(&item->list);
+		free(item);
+	}
+
+	tmp_len = *plen - 6;
+
+	cfg_buf[4] = (tmp_len & 0xff);
+	cfg_buf[5] = ((tmp_len >> 8) & 0xff);
+}
+
+/*
+ * Parse realtek Bluetooth config file.
+ * The content starts with vendor magic: 55 ab 23 87
+ */
+int rtb_parse_config(uint8_t *cfg_buf, size_t *plen, uint8_t bdaddr[6])
+{
+	const uint8_t hdr[4] = { 0x55, 0xab, 0x23, 0x87 };
+	uint16_t cfg_len;
+	uint16_t tmp;
+	struct rtb_cfg_item *entry;
+	uint16_t i;
+	uint32_t baudrate = 0;
+#ifdef USE_CUSTOMER_ADDRESS
+	uint8_t j = 0;
+	struct patch_info *pent = rtb_cfg.patch_ent;
+	int addr_found = 0;
+#endif
+	struct cfg_list_item *item;
+
+	if (!cfg_buf || !plen) {
+		RS_ERR("%s: Invalid parameter", __func__);
+		return -1;
+	}
+
+	RS_INFO("Original Cfg len %u", (uint16_t)*plen);
+	if (memcmp(cfg_buf, hdr, 4)) {
+		RS_ERR("Signature %02x %02x %02x %02x is incorrect",
+		       cfg_buf[0], cfg_buf[1], cfg_buf[2], cfg_buf[3]);
+		return -1;
+	}
+
+	cfg_len = ((uint16_t)cfg_buf[5] << 8) + cfg_buf[4];
+	if (cfg_len != *plen - RTB_CFG_HDR_LEN) {
+		RS_ERR("Config len %u is incorrect(%zd)", cfg_len,
+		       *plen - RTB_CFG_HDR_LEN);
+		return -1;
+	}
+
+	entry = (struct rtb_cfg_item *)(cfg_buf + 6);
+	i = 0;
+	while (i < cfg_len) {
+		switch (le16_to_cpu(entry->offset)) {
+#ifdef USE_CUSTOMER_ADDRESS
+		case 0x003c:
+		case 0x0044:
+		case 0x0030:
+			if (!customer_bdaddr)
+				break;
+			if (!is_mac(pent->chip_type, le16_to_cpu(entry->offset)))
+				break;
+			/* Replace the content with input bdaddr from extra
+			 * config file
+			 */
+			for (j = 0; j < entry->len; j++)
+				entry->data[j] = bdaddr[j];
+			addr_found = 1;
+			RS_INFO("BT MAC found %02x:%02x:%02x:%02x:%02x:%02x",
+				entry->data[5], entry->data[4], entry->data[3],
+				entry->data[2], entry->data[1], entry->data[0]);
+			break;
+#endif
+		case 0x000c:
+#ifdef BAUDRATE_4BYTES
+			baudrate = get_unaligned_le32(entry->data);
+#else
+			baudrate = get_unaligned_le16(entry->data);
+#endif
+			RS_INFO("Config baudrate: %08x", baudrate);
+
+			if (entry->len > 12) {
+				uint8_t d = entry->data[12];
+				rtb_cfg.uart_flow_ctrl = (d & 0x4) ? 1 : 0;
+				RS_INFO("uart flow ctrl: %u",
+					rtb_cfg.uart_flow_ctrl);
+			}
+			break;
+#ifdef RTL8723DSH4_UART_HWFLOWC
+		case 0x0018:
+			if (pent->chip_type == CHIP_8723DS &&
+			    rtb_cfg.proto == HCI_UART_H4) {
+				if (entry->data[0] & (1 << 2))
+					rtb_cfg.uart_flow_ctrl = 1;
+				RS_INFO("8723DSH4: hw flow control %u",
+					rtb_cfg.uart_flow_ctrl);
+				if (entry->data[0] & 0x01) {
+					rtb_cfg.parenb = 1;
+					if (entry->data[0] & 0x02)
+						rtb_cfg.pareven = 1;
+					else
+						rtb_cfg.pareven = 0;
+				}
+				RS_INFO("8723DSH4: parity %u, even %u",
+					rtb_cfg.parenb,
+					rtb_cfg.pareven);
+			}
+			break;
+#endif
+		default:
+			RS_DBG("cfg offset %04x, length %u", entry->offset,
+			       entry->len);
+			break;
+		}
+
+		/* Add config item to list */
+		item = malloc(sizeof(*item) + entry->len);
+		if (item) {
+			memset(item, 0, sizeof(*item));
+			item->cfg_data = entry->data;
+			item->offset = le16_to_cpu(entry->offset);
+			item->len = entry->len;
+			memcpy(item->data, entry->data, item->len);
+			list_add_tail(&item->list, &list_configs);
+		} else {
+			RS_ERR("Cannot alloc mem for entry %04x, %u",
+			       entry->offset, entry->len);
+		}
+
+		tmp = entry->len + sizeof(struct rtb_cfg_item);
+		i += tmp;
+		entry = (struct rtb_cfg_item *)((uint8_t *)entry + tmp);
+	}
+
+#ifdef USE_CUSTOMER_ADDRESS
+	if (!addr_found && customer_bdaddr) {
+		uint8_t *b;
+		uint16_t ofs;
+
+		b = cfg_buf + *plen;
+		fill_mac_offset(pent->chip_type, b);
+		ofs = (((uint16_t)b[1] << 8) | b[0]);
+
+		RS_INFO("Add bdaddr section, offset %02x%02x", b[1], b[0]);
+		b[2] = 6;
+		for (j = 0; j < 6; j++)
+			b[3 + j] = bdaddr[j];
+
+		*plen += 9;
+		tmp = *plen - 6;
+
+		cfg_buf[4] = (tmp & 0xff);
+		cfg_buf[5] = ((tmp >> 8) & 0xff);
+
+		/* Add address item to list */
+		item = malloc(sizeof(*item) + 6);
+		if (item) {
+			memset(item, 0, sizeof(*item));
+			item->cfg_data = b + 3;
+			item->offset = ofs;
+			item->len = b[2];
+			memcpy(item->data, b + 3, 6);
+			list_add_tail(&item->list, &list_configs);
+		} else {
+			RS_ERR("Cannot alloc mem for entry %04x, %u",
+			       entry->offset, entry->len);
+		}
+	}
+#endif
+
+	/* plen, cfg_buf, head */
+	/* Merge configs */
+	merge_configs(cfg_buf, plen);
+
+	rtb_cfg.vendor_baud = baudrate;
+	return 0;
+}
+
+#ifdef USE_CUSTOMER_ADDRESS
+int bachk(const char *str)
+{
+	if (!str)
+		return -1;
+
+	if (strlen(str) != 17)
+		return -1;
+
+	while (*str) {
+		if (!isxdigit(*str++))
+			return -1;
+
+		if (!isxdigit(*str++))
+			return -1;
+
+		if (*str == 0)
+			break;
+
+		if (*str++ != ':')
+			return -1;
+	}
+
+	return 0;
+}
+/*
+ * Get random Bluetooth addr.
+ */
+/* static void rtb_get_ram_addr(char bt_addr[0])
+ * {
+ * 	srand(time(NULL) + getpid() + getpid() * 987654 + rand());
+ * 
+ * 	uint32_t addr = rand();
+ * 	memcpy(bt_addr, &addr, sizeof(uint8_t));
+ * }
+ */
+
+/*
+ * Write the random addr to the BT_ADDR_FILE.
+ */
+/* static void rtb_write_btmac2file(char bt_addr[6])
+ * {
+ * 	int fd;
+ * 	fd = open(BT_ADDR_FILE, O_CREAT | O_RDWR | O_TRUNC);
+ * 
+ * 	if (fd > 0) {
+ * 		chmod(BT_ADDR_FILE, 0666);
+ * 		char addr[18] = { 0 };
+ * 		addr[17] = '\0';
+ * 		sprintf(addr, "%2x:%2x:%2x:%2x:%2x:%2x", bt_addr[0], bt_addr[1],
+ * 			bt_addr[2], bt_addr[3], bt_addr[4], bt_addr[5]);
+ * 		write(fd, addr, strlen(addr));
+ * 		close(fd);
+ * 	} else {
+ * 		RS_ERR("open file error:%s\n", BT_ADDR_FILE);
+ * 	}
+ * }
+ */
+#endif
+
+/*
+ * Read and parse Realtek Bluetooth Config file.
+ */
+uint8_t *rtb_read_config(struct rtb_struct *btrtl, int *cfg_len)
+{
+	char *file_name;
+	uint8_t bdaddr[6];
+	struct stat st;
+	size_t file_len;
+	size_t tlength;
+	int fd;
+	uint8_t *buf;
+#ifdef USE_CUSTOMER_ADDRESS
+#define BDADDR_STRING_LEN	17
+	size_t size;
+	size_t result;
+	uint8_t tbuf[BDADDR_STRING_LEN + 1];
+	char *str;
+	int i = 0;
+#endif
+	struct list_head *tmp, *iter;
+
+	if (!btrtl || !cfg_len) {
+		RS_ERR("%s: Invalid parameter", __func__);
+		return NULL;
+	}
+
+	config_lists_init();
+
+#ifdef USE_CUSTOMER_ADDRESS
+	if (stat(BT_ADDR_FILE, &st) < 0) {
+		RS_INFO("Couldnt access customer BT MAC file %s",
+		        BT_ADDR_FILE);
+
+		goto read_cfg;
+	}
+
+	size = st.st_size;
+	/* Only read the first 17-byte if the file length is larger */
+	if (size > BDADDR_STRING_LEN)
+		size = BDADDR_STRING_LEN;
+
+	fd = open(BT_ADDR_FILE, O_RDONLY);
+	if (fd == -1) {
+		RS_INFO("Couldnt open BT MAC file %s, %s", BT_ADDR_FILE,
+			strerror(errno));
+	} else {
+		memset(tbuf, 0, sizeof(tbuf));
+		result = read(fd, tbuf, size);
+		close(fd);
+		if (result == -1) {
+			RS_ERR("Couldnt read BT MAC file %s, err %s",
+			       BT_ADDR_FILE, strerror(errno));
+			goto read_cfg;
+		}
+
+		if (bachk((const char *)tbuf) < 0) {
+			goto read_cfg;
+		}
+
+		str = (char *)tbuf;
+		for (i = 5; i >= 0; i--) {
+			bdaddr[i] = (uint8_t)strtoul(str, NULL, 16);
+			str += 3;
+		}
+
+		/* Reserve LAP addr from 0x9e8b00 to 0x9e8b3f,
+		 * Change to 0x008bXX */
+		if (0x9e == bdaddr[3] && 0x8b == bdaddr[4] &&
+		    bdaddr[5] <= 0x3f)
+			bdaddr[3] = 0x00;
+
+		RS_DBG("BT MAC %02x:%02x:%02x:%02x:%02x:%02x",
+		       bdaddr[5], bdaddr[4], bdaddr[3], bdaddr[2],
+		       bdaddr[1], bdaddr[0]);
+		customer_bdaddr = 1;
+	}
+#endif
+
+read_cfg:
+	*cfg_len = 0;
+	file_name = malloc(PATH_MAX);
+	if (!file_name) {
+		RS_ERR("Can't allocate memory for Config file name");
+		return NULL;
+	}
+	memset(file_name, 0, PATH_MAX);
+	snprintf(file_name, PATH_MAX, "%s%s", BT_CONFIG_DIRECTORY,
+		 btrtl->patch_ent->config_file);
+	if (stat(file_name, &st) < 0) {
+		RS_ERR("Can't access Config file: %s, %s",
+		       file_name, strerror(errno));
+		goto err_stat;
+	}
+
+	file_len = st.st_size;
+
+	if ((fd = open(file_name, O_RDONLY)) < 0) {
+		perror("Can't open Config file");
+		goto err_open;
+	}
+
+	tlength = file_len;
+#ifdef USE_CUSTOMER_ADDRESS
+	tlength += 9;
+#endif
+
+	parse_extra_config(EXTRA_CONFIG_FILE);
+	if (!list_empty(&list_extracfgs)) {
+		struct cfg_list_item *item;
+
+		list_for_each_safe(iter, tmp, &list_extracfgs) {
+			item = list_entry(iter, struct cfg_list_item, list);
+			tlength += (item->len + 3);
+		}
+	}
+
+	buf = malloc(tlength);
+	if (!buf) {
+		RS_ERR("Couldnt malloc buffer for Config %zd", tlength);
+		goto err_malloc;
+	}
+
+	result = read(fd, buf, file_len);
+	if (result < (ssize_t)file_len) {
+		perror("Can't read Config file");
+		goto err_read;
+	}
+	close(fd);
+	free(file_name);
+
+	result = rtb_parse_config(buf, &file_len, bdaddr);
+	config_lists_free();
+	if (result < 0) {
+		RS_ERR("Invalid Config content");
+		close(fd);
+		free(buf);
+		exit(EXIT_FAILURE);
+	}
+	util_hexdump((const uint8_t *)buf, file_len);
+	RS_INFO("Cfg length %u", (uint16_t)file_len);
+	RS_INFO("Vendor baud from Config file: %08x", rtb_cfg.vendor_baud);
+
+	*cfg_len = file_len;
+
+	return buf;
+
+err_read:
+	free(buf);
+err_malloc:
+	config_lists_free();
+	close(fd);
+err_open:
+err_stat:
+	free(file_name);
+	return NULL;
+}
+
+/*
+ * Read Realtek Bluetooth firmaware file.
+ */
+uint8_t *rtb_read_firmware(struct rtb_struct *btrtl, int *fw_len)
+{
+	char *filename;
+	struct stat st;
+	int fd = -1;
+	size_t fwsize;
+	uint8_t *fw_buf;
+	ssize_t result;
+
+	if (!btrtl || !fw_len) {
+		RS_ERR("%s: Invalid parameter", __func__);
+		return NULL;
+	}
+
+	filename = malloc(PATH_MAX);
+	if (!filename) {
+		RS_ERR("Can't allocate memory for fw name");
+		return NULL;
+	}
+
+	snprintf(filename, PATH_MAX, "%s%s", FIRMWARE_DIRECTORY,
+		 btrtl->patch_ent->patch_file);
+
+	if (stat(filename, &st) < 0) {
+		RS_ERR("Can't access firmware %s, %s", filename,
+		       strerror(errno));
+		goto err_stat;
+	}
+
+	fwsize = st.st_size;
+
+	if ((fd = open(filename, O_RDONLY)) < 0) {
+		RS_ERR("Can't open firmware, %s", strerror(errno));
+		goto err_open;
+	}
+
+	fw_buf = malloc(fwsize);
+	if (!fw_buf) {
+		RS_ERR("Can't allocate memory for fw, %s", strerror(errno));
+		goto err_malloc;
+	}
+
+	result = read(fd, fw_buf, fwsize);
+	if (result != (ssize_t) fwsize) {
+		RS_ERR("Read FW %s error, %s", filename, strerror(errno));
+		goto err_read;
+	}
+
+	*fw_len = (int)result;
+	RS_INFO("Load FW %s OK, size %zd", filename, result);
+
+	close(fd);
+	free(filename);
+
+	return fw_buf;
+
+err_read:
+	free(fw_buf);
+	*fw_len = 0;
+err_malloc:
+	close(fd);
+err_open:
+err_stat:
+	free(filename);
+	return NULL;
+}
+
+static uint8_t rtb_get_fw_project_id(uint8_t *p_buf)
+{
+	uint8_t opcode;
+	uint8_t len;
+	uint8_t data = 0;
+
+	do {
+		opcode = *p_buf;
+		len = *(p_buf - 1);
+		if (opcode == 0x00) {
+			if (len == 1) {
+				data = *(p_buf - 2);
+				RS_INFO("%s: opcode %u, len %u, data %u",
+					__func__, opcode, len, data);
+				break;
+			} else {
+				RS_ERR("%s: Invalid len %u", __func__, len);
+			}
+		}
+		p_buf -= len + 2;
+	} while (*p_buf != 0xFF);
+
+	return data;
+}
+
+struct rtb_patch_entry *rtb_get_patch_entry(void)
+{
+	uint16_t i;
+	struct rtb_patch_hdr *patch;
+	struct rtb_patch_entry *entry;
+	uint32_t tmp;
+	uint8_t *ci_base; /* Chip id base */
+	uint8_t *pl_base; /* Patch length base */
+	uint8_t *so_base; /* Start offset base */
+
+	patch = (struct rtb_patch_hdr *)rtb_cfg.fw_buf;
+	entry = (struct rtb_patch_entry *)malloc(sizeof(*entry));
+	if (!entry) {
+		RS_ERR("Failed to allocate mem for patch entry");
+		return NULL;
+	}
+
+	patch->number_of_patch = le16_to_cpu(patch->number_of_patch);
+
+	RS_DBG("FW version 0x%08x, Patch num %u",
+	       le32_to_cpu(patch->fw_version), patch->number_of_patch);
+
+	ci_base = rtb_cfg.fw_buf + 14;
+	pl_base = ci_base + 2 * patch->number_of_patch;
+	so_base = pl_base + 2 * patch->number_of_patch;
+	for (i = 0; i < patch->number_of_patch; i++) {
+		uint16_t chip_id = get_unaligned_le16(ci_base + 2 * i);
+
+		RS_INFO("Chip id 0x%04x", chip_id);
+		if (chip_id == rtb_cfg.eversion + 1) {
+			entry->chip_id = rtb_cfg.eversion + 1;
+			entry->patch_len = get_unaligned_le16(pl_base + 2 * i);
+			entry->soffset = get_unaligned_le32(so_base + 4 * i);
+			RS_DBG("Patch length 0x%04x", entry->patch_len);
+			RS_DBG("Start offset 0x%08x", entry->soffset);
+
+			entry->svn_ver = get_unaligned_le32(rtb_cfg.fw_buf +
+						entry->soffset +
+						entry->patch_len - 8);
+			entry->coex_ver = get_unaligned_le32(rtb_cfg.fw_buf +
+						entry->soffset +
+						entry->patch_len - 12);
+
+			RS_INFO("Svn version: %8d", entry->svn_ver);
+			tmp = ((entry->coex_ver >> 16) & 0x7ff) +
+			      (entry->coex_ver >> 27) * 10000;
+			RS_INFO("Coexistence: BTCOEX_20%06d-%04x\n", tmp,
+				(entry->coex_ver & 0xffff));
+
+			break;
+		}
+	}
+
+	if (i == patch->number_of_patch) {
+		RS_ERR("Failed to get entry");
+		free(entry);
+		entry = NULL;
+	}
+
+	return entry;
+}
+
+uint8_t *rtb_get_final_patch(int fd, int proto, int *rlen)
+{
+	struct rtb_struct *rtl = &rtb_cfg;
+	uint8_t proj_id = 0;
+	struct rtb_patch_entry *entry = NULL;
+	struct rtb_patch_hdr *patch = (struct rtb_patch_hdr *)rtl->fw_buf;
+	uint32_t svn_ver, coex_ver, tmp;
+	const uint8_t rtb_patch_smagic[8] = {
+		0x52, 0x65, 0x61, 0x6C, 0x74, 0x65, 0x63, 0x68
+	};
+	const uint8_t rtb_patch_emagic[4] = { 0x51, 0x04, 0xFD, 0x77 };
+	uint8_t *buf;
+	int len;
+
+	if (!rlen) {
+		RS_ERR("%s: Invalid parameter", __func__);
+		return NULL;
+	}
+
+	/* Use single patch for 3wire && 8723a */
+	if (proto == HCI_UART_3WIRE && rtl->lmp_subver == ROM_LMP_8723a) {
+		if (!memcmp(rtl->fw_buf, rtb_patch_smagic, 8)) {
+			RS_ERR("Unexpected signature");
+			goto err;
+		}
+
+		len = rtl->config_len + rtl->fw_len;
+		buf = malloc(len);
+		if (!buf) {
+			RS_ERR("Can't alloc mem for fwc, %s", strerror(errno));
+			goto err;
+		} else {
+			uint8_t *b;
+
+			RS_INFO("FWC copy directly");
+
+			b = rtl->fw_buf + rtl->fw_len;
+			svn_ver = get_unaligned_le32(b - 8);
+			coex_ver = get_unaligned_le32(b - 12);
+
+			RS_INFO("Svn version: %u\n", svn_ver);
+			tmp = ((coex_ver >> 16) & 0x7ff) +
+			      (coex_ver >> 27) * 10000;
+			RS_INFO("Coexistence: BTCOEX_20%06d-%04x\n", tmp,
+				(coex_ver & 0xffff));
+
+			/* Copy Patch and Config */
+			memcpy(buf, rtl->fw_buf, rtl->fw_len);
+			if (rtl->config_len)
+				memcpy(buf + rtl->fw_len,
+				       rtl->config_buf, rtl->config_len);
+			rtl->dl_fw_flag = 1;
+			*rlen = len;
+			return buf;
+		}
+	}
+
+	if (memcmp(rtl->fw_buf, rtb_patch_smagic, 8)) {
+		RS_ERR("Signature error");
+		goto err;
+	}
+
+	if (memcmp(rtl->fw_buf + rtl->fw_len - 4, rtb_patch_emagic, 4)) {
+		RS_ERR("Extension section signature error");
+		goto err;
+	}
+
+	proj_id = rtb_get_fw_project_id(rtl->fw_buf + rtl->fw_len - 5);
+
+#ifdef RTL_8703A_SUPPORT
+	if (rtl->hci_ver == 0x4 && rtl->lmp_subver == ROM_LMP_8723b) {
+		RS_INFO("HCI version = 0x4, IC is 8703A.");
+	} else {
+		RS_ERR("error: lmp_version %x, hci_version %x, project_id %x",
+		       rtl->lmp_subver, rtl->hci_ver, project_id[proj_id]);
+		goto err;
+	}
+#else
+	if (rtl->lmp_subver != ROM_LMP_8703b) {
+		if (rtl->lmp_subver != project_id[proj_id]) {
+			RS_ERR("lmp_subver %04x, project id %04x, mismatch\n",
+			       rtl->lmp_subver, project_id[proj_id]);
+			goto err;
+		}
+	} else {
+		if (rtb_cfg.patch_ent->proj_id != project_id[proj_id]) {
+			RS_ERR("proj_id %04x, version %04x from firmware "
+			       "project_id[%u], mismatch",
+			       rtb_cfg.patch_ent->proj_id,
+			       project_id[proj_id], proj_id);
+			goto err;
+		}
+	}
+#endif
+
+	/* Entry is allocated dynamically. It should be freed later in the
+	 * function.
+	 */
+	entry = rtb_get_patch_entry();
+
+	if (entry) {
+		len = entry->patch_len + rtl->config_len;
+	} else {
+		RS_ERR("Can't find the patch entry");
+		goto err;
+	}
+
+	buf = malloc(len);
+	if (!buf) {
+		RS_ERR("%s: Can't alloc memory for fwc, %s", __func__,
+		       strerror(errno));
+		free(entry);
+		goto err;
+	} else {
+		memcpy(buf, rtl->fw_buf + entry->soffset, entry->patch_len);
+		memcpy(buf + entry->patch_len - 4, &patch->fw_version, 4);
+
+		if (rtl->config_len)
+			memcpy(buf + entry->patch_len, rtl->config_buf,
+			       rtl->config_len);
+		rtl->dl_fw_flag = 1;
+		*rlen = len;
+	}
+
+	RS_INFO("FW %s exists, Config file %s exists",
+		(rtl->fw_len > 0) ? "" : "not",
+		(rtl->config_len > 0) ? "" : "not");
+
+	free(entry);
+	return buf;
+
+err:
+	rtl->dl_fw_flag = 0;
+	*rlen = 0;
+	return NULL;
+}
+
diff --git a/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/rtb_fwc.h b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/rtb_fwc.h
new file mode 100644
index 0000000..c0e1571
--- /dev/null
+++ b/recipes-multimedia/rtk-hciattach/files/rtk_hciattach/rtb_fwc.h
@@ -0,0 +1,75 @@
+/*
+ *  Copyright (C) 2018 Realtek Semiconductor Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+struct rtb_struct;
+
+#define BAUDRATE_4BYTES
+
+#define ROM_LMP_NONE            0x0000
+#define ROM_LMP_8723a           0x1200
+#define ROM_LMP_8723b           0x8723
+#define ROM_LMP_8821a           0x8821
+#define ROM_LMP_8761a           0x8761
+#define ROM_LMP_8761btc		0x8763
+
+#define ROM_LMP_8703a           0x87b3
+#define ROM_LMP_8763a           0x8763
+#define ROM_LMP_8703b           0x8703
+#define ROM_LMP_8723c           0x87c3 /* ??????? */
+#define ROM_LMP_8822b           0x8822
+#define ROM_LMP_8822c           0x8822
+#define ROM_LMP_8723cs_xx       0x8704
+#define ROM_LMP_8723cs_cg       0x8705
+#define ROM_LMP_8723cs_vf       0x8706
+
+/* Chip type */
+#define CHIP_8703AS    1
+#define CHIP_8723CS_CG 3
+#define CHIP_8723CS_VF 4
+#define CHIP_8723CS_XX 5
+#define CHIP_8703BS   7
+
+/* software id */
+#define CHIP_UNKNOWN	0x00
+#define CHIP_8761AT	0x1F
+#define CHIP_8761ATF	0x2F
+#define CHIP_8761BTC	0x3F
+#define CHIP_8761BH4	0x4F
+#define CHIP_8723BS	0x5F
+#define CHIP_BEFORE	0x6F
+#define CHIP_8822BS	0x70
+#define CHIP_8723DS	0x71
+#define CHIP_8821CS	0x72
+#define CHIP_8822CS	0x73
+#define CHIP_8761B	0x74
+
+#define RTL_FW_MATCH_CHIP_TYPE  (1 << 0)
+#define RTL_FW_MATCH_HCI_VER    (1 << 1)
+#define RTL_FW_MATCH_HCI_REV    (1 << 2)
+struct patch_info {
+	uint32_t    match_flags;
+	uint8_t     chip_type;
+	uint16_t    lmp_subver;
+	uint16_t    proj_id;
+	uint8_t     hci_ver;
+	uint16_t    hci_rev;
+	char        *patch_file;
+	char        *config_file;
+	char        *ic_name;
+};
+
+struct patch_info *get_patch_entry(struct rtb_struct *btrtl);
+uint8_t *rtb_read_config(struct rtb_struct *btrtl, int *cfg_len);
+uint8_t *rtb_read_firmware(struct rtb_struct *btrtl, int *fw_len);
+uint8_t *rtb_get_final_patch(int fd, int proto, int *rlen);
diff --git a/recipes-multimedia/rtk-hciattach/rtk-hciattach_1.0.0.bb b/recipes-multimedia/rtk-hciattach/rtk-hciattach_1.0.0.bb
new file mode 100644
index 0000000..f298ec4
--- /dev/null
+++ b/recipes-multimedia/rtk-hciattach/rtk-hciattach_1.0.0.bb
@@ -0,0 +1,31 @@
+SUMMARY = "Realtek hciattach tool"
+LICENSE = "GPLv2"
+LIC_FILES_CHKSUM = "file://${WORKDIR}/LICENSE;md5=12f884d2ae1ff87c09e5b7ccc2c4ca7e"
+
+FILESEXTRAPATHS_prepend := "${THISDIR}:${THISDIR}/files/rtk_hciattach:"
+
+SRC_URI = "file://Makefile \
+           file://hciattach.c \
+           file://hciattach.h \
+           file://hciattach_h4.c \
+           file://hciattach_h4.h \
+           file://hciattach_rtk.c \
+           file://rtb_fwc.c \
+           file://rtb_fwc.h \
+           file://8822CS/Makefile \
+           file://8822CS/rtl8822cs_config \
+           file://8822CS/rtl8822cs_fw \
+           file://LICENSE \
+"
+S = "${WORKDIR}"
+
+do_install(){
+	install -d ${D}/usr/sbin
+	install -m 755 ${WORKDIR}/rtk_hciattach ${D}/usr/sbin
+	install -d 755 ${D}/lib/firmware/rtlbt
+	install -m 755 ${WORKDIR}/8822CS/rtl8822cs_fw ${D}/lib/firmware/rtlbt/
+	install -m 755 ${WORKDIR}/8822CS/rtl8822cs_config ${D}/lib/firmware/rtlbt/
+}
+
+FILES_${PN} += "/lib/firmware/rtlbt /usr/sbin"
+TARGET_CC_ARCH += "${LDFLAGS}"
-- 
2.17.1

